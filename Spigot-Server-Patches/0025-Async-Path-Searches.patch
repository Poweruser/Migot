From d289b9bbe5fc680f19ab438a56d6c92e0b352545 Mon Sep 17 00:00:00 2001
From: Poweruser <poweruser.rs@hotmail.com>
Date: Wed, 6 Jan 2016 03:30:52 +0100
Subject: [PATCH] Async Path Searches


diff --git a/src/main/java/de/minetick/Migot.java b/src/main/java/de/minetick/Migot.java
index 3d03d29..24a2710 100644
--- a/src/main/java/de/minetick/Migot.java
+++ b/src/main/java/de/minetick/Migot.java
@@ -26,6 +26,8 @@ import org.bukkit.craftbukkit.CraftServer;
 
 import de.minetick.command.ReloadSettingsCommand;
 import de.minetick.command.TPSCommand;
+import de.minetick.pathsearch.PathSearchJob;
+import de.minetick.pathsearch.PathSearchThrottlerThread;
 
 public class Migot {
 
@@ -42,6 +44,7 @@ public class Migot {
     private List<Integer> ticksPerSecond;
     private int ticksCounter = 0;
     private final Logger log = LogManager.getLogger();
+    private PathSearchThrottlerThread pathSearchThrottler;
 
     public Migot() {
         this.tickTimerObject = new TickTimer();
@@ -59,6 +62,7 @@ public class Migot {
             // Bukkit's logger is not yet initialized at this point and throws an NPE when trying to log an yaml load fail
             this.failedToLoadConfig = true;
         }
+        this.pathSearchThrottler = new PathSearchThrottlerThread(this.mainConfig.getPathSearchPoolSize());
     }
 
     public void init() {
@@ -80,6 +84,7 @@ public class Migot {
     public void shutdown() {
         this.timerService.shutdown();
         this.nbtFileService.shutdown();
+        this.pathSearchThrottler.shutdown();
         while(!this.nbtFileService.isTerminated()) {
             try {
                 if(!this.nbtFileService.awaitTermination(3, TimeUnit.MINUTES)) {
@@ -175,4 +180,8 @@ public class Migot {
             return null;
         }
     }
+
+    public static boolean queuePathSearch(PathSearchJob pathSearchJob) {
+        return instance.pathSearchThrottler.queuePathSearch(pathSearchJob);
+    }
 }
diff --git a/src/main/java/de/minetick/MigotConfig.java b/src/main/java/de/minetick/MigotConfig.java
index 28036a4..bd37253 100644
--- a/src/main/java/de/minetick/MigotConfig.java
+++ b/src/main/java/de/minetick/MigotConfig.java
@@ -4,6 +4,10 @@ import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStreamReader;
+import java.util.HashSet;
+import java.util.List;
+
+import net.minecraft.server.EntityInsentient;
 
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -11,14 +15,19 @@ import org.apache.logging.log4j.Logger;
 import org.bukkit.configuration.InvalidConfigurationException;
 import org.bukkit.configuration.file.FileConfiguration;
 import org.bukkit.configuration.file.YamlConfiguration;
+import org.bukkit.entity.EntityType;
 
 import com.google.common.base.Charsets;
 
+import de.minetick.pathsearch.MigotNavigation;
+import de.minetick.pathsearch.PathSearchThrottlerThread;
+
 public class MigotConfig {
 
     private final Logger logger = LogManager.getLogger();
     private File configFile;
     private FileConfiguration configuration;
+    private HashSet<EntityType> entitiesWithOffloadedPathSearches = new HashSet<EntityType>();
 
     public MigotConfig(File configFile) throws IOException, InvalidConfigurationException {
         this.configFile = configFile;
@@ -43,7 +52,9 @@ public class MigotConfig {
     }
 
     private void loadConfigContent() {
-
+        this.loadEntitiesWithOffloadedPathSearches(this.getEntitiesWithOffloadedPathSearches());
+        MigotNavigation.setMinimumDistanceForOffloading(this.getMinimumTargetDistanceForOffloading());
+        PathSearchThrottlerThread.adjustPoolSize(this.getPathSearchPoolSize());
     }
 
     private FileConfiguration loadConfig(File file) throws IOException, InvalidConfigurationException {
@@ -63,4 +74,37 @@ public class MigotConfig {
         }
         return config;
     }
+
+    public List<String> getEntitiesWithOffloadedPathSearches() {
+        return configuration.getStringList("async-pathsearches.entities");
+    }
+
+    public double getMinimumTargetDistanceForOffloading() {
+        return configuration.getDouble("async-pathsearches.minimumDistanceToTarget", 0.0D);
+    }
+
+    private void loadEntitiesWithOffloadedPathSearches(List<String> entities) {
+        this.entitiesWithOffloadedPathSearches.clear();
+        for(String name: entities) {
+            try {
+                EntityType type = EntityType.valueOf(name.toUpperCase());
+                this.entitiesWithOffloadedPathSearches.add(type);
+            } catch (IllegalArgumentException e) {
+                logger.warn("[Migot] Settings: Skipping \"" + name + "\", as it is not a constant in org.bukkit.entity.EntityType!");
+            }
+        }
+    }
+
+    public boolean isPathSearchOffloadedFor(EntityInsentient entity) {
+        return this.getOffloadedPathSearchesEnabled() && this.entitiesWithOffloadedPathSearches.contains(entity.getBukkitEntity().getType());
+    }
+
+    public int getPathSearchPoolSize() {
+        int threadcount = configuration.getInt("async-pathsearches.threadPoolSize", 2);
+        return Math.max(1, Math.min(threadcount, 32));
+    }
+
+    public boolean getOffloadedPathSearchesEnabled() {
+        return configuration.getBoolean("async-pathsearches.enabled", true);
+    }
 }
diff --git a/src/main/java/de/minetick/pathsearch/MigotNavigation.java b/src/main/java/de/minetick/pathsearch/MigotNavigation.java
new file mode 100644
index 0000000..ef6a006
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/MigotNavigation.java
@@ -0,0 +1,222 @@
+package de.minetick.pathsearch;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.UUID;
+import java.util.Map.Entry;
+
+import de.minetick.Migot;
+import de.minetick.pathsearch.cache.SearchCacheEntry;
+import de.minetick.pathsearch.cache.SearchCacheEntryEntity;
+import de.minetick.pathsearch.cache.SearchCacheEntryPosition;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.MathHelper;
+import net.minecraft.server.Navigation;
+import net.minecraft.server.PathEntity;
+import net.minecraft.server.World;
+
+public class MigotNavigation extends Navigation {
+    
+    private HashMap<UUID, SearchCacheEntry> searchCache;
+    private HashMap<PositionPathSearchType, SearchCacheEntryPosition> positionSearchCache;
+    private static double minimumDistanceForOffloadingSquared = 0.0D;
+    private int cleanUpDelay = 0;
+    private Object jobLock = new Object();
+    private PathSearchJob lastQueuedJob;
+    
+    public MigotNavigation(EntityInsentient entityinsentient, World world) {
+        super(entityinsentient, world);
+        this.searchCache = new HashMap<UUID, SearchCacheEntry>();
+        this.positionSearchCache = new HashMap<PositionPathSearchType, SearchCacheEntryPosition>();
+    }
+
+    public static void setMinimumDistanceForOffloading(double distance) {
+        minimumDistanceForOffloadingSquared = distance * distance;
+    }
+
+    private boolean hasAsyncSearchIssued() {
+        synchronized(this.jobLock) {
+            return this.lastQueuedJob != null;
+        }
+    }
+
+    private void queueSearch(PathSearchJob job) {
+        synchronized(this.jobLock) {
+            PathSearchJob previous = this.lastQueuedJob;
+            if(Migot.queuePathSearch(job)) {
+                this.lastQueuedJob = job;
+            }
+        }
+    }
+
+    private void issueSearch(Entity target) {
+        this.queueSearch(new PathSearchJobEntity(this, target));
+    }
+
+    private void issueSearch(BlockPosition blockposition, PositionPathSearchType type) {
+        this.queueSearch(new PathSearchJobPosition(this, blockposition, type));
+    }
+
+    @Override
+    public void setSearchResult(PathSearchJobEntity pathSearch) {
+        synchronized (this.jobLock) {
+            if(this.lastQueuedJob == pathSearch) {
+                this.lastQueuedJob = null;
+            }
+        }
+        SearchCacheEntry entry = pathSearch.getCacheEntryValue();
+        if(entry != null && entry.didSearchSucceed()) {
+            synchronized(this.searchCache) {
+                UUID key = pathSearch.getCacheEntryKey();
+                this.searchCache.remove(key);
+                this.searchCache.put(key, entry);
+            }
+        }
+    }
+
+    @Override
+    public void setSearchResult(PathSearchJobPosition pathSearch) {
+        synchronized(this.jobLock) {
+            if(this.lastQueuedJob == pathSearch) {
+                this.lastQueuedJob = null;
+            }
+        }
+        SearchCacheEntryPosition entry = pathSearch.getCacheEntryValue();
+        if(entry != null && entry.didSearchSucceed()) {
+            synchronized(this.positionSearchCache) {
+                PositionPathSearchType key = pathSearch.getCacheEntryKey();
+                this.positionSearchCache.remove(key);
+                this.positionSearchCache.put(key, entry);
+            }
+        }
+    }
+
+    @Override
+    public PathEntity a(Entity entity) {
+        if(!this.offloadSearches() || this.b.h(entity) < minimumDistanceForOffloadingSquared) {
+            return super.a(entity);
+        }
+        if(!this.b()) {
+            return null;
+        }
+        SearchCacheEntry entry = null;
+        UUID id = entity.getUniqueID();
+        synchronized(this.searchCache) {
+            if(this.searchCache.containsKey(id)) {
+                entry = this.searchCache.get(id);
+            }
+        }
+        PathEntity resultPath = null;
+        if(entry != null) {
+            resultPath = entry.getAdjustedPathEntity();
+            if(!entry.isStillValid()) {
+                this.issueSearch(entity);
+            }
+        }
+        if(entry == null && !this.hasAsyncSearchIssued()) {
+            resultPath = super.a(entity);
+            if(resultPath != null) {
+                entry = new SearchCacheEntryEntity(this.b, entity, resultPath);
+                synchronized(this.searchCache) {
+                    SearchCacheEntry oldEntry = this.searchCache.put(id, entry);
+                    if(oldEntry != null) {
+                        oldEntry.cleanup();
+                    }
+                }
+            }
+        }
+        return resultPath;
+    }
+
+    @Override
+    public PathEntity a(BlockPosition blockposition) {
+        return this.a(blockposition, PositionPathSearchType.ANYOTHER);
+    }
+
+    public PathEntity a(BlockPosition blockposition, PositionPathSearchType type) {
+        if(!this.offloadSearches() || this.b.c(blockposition) < minimumDistanceForOffloadingSquared) {
+            return super.a(blockposition);
+        }
+        if(!this.b()) {
+            return null;
+        }
+
+        SearchCacheEntryPosition entry = null;
+        synchronized(this.positionSearchCache) {
+            if(this.positionSearchCache.containsKey(type)) {
+                entry = this.positionSearchCache.get(type);
+            }
+        }
+
+        PathEntity resultPath = null;
+        if(entry != null) {
+            resultPath = entry.getAdjustedPathEntity();
+            if(!entry.isStillValid()) {
+                this.issueSearch(blockposition, type);
+            }
+        }
+        if(entry == null && !this.hasAsyncSearchIssued()) {
+            resultPath = super.a(blockposition);
+            if(resultPath != null) {
+                entry = new SearchCacheEntryPosition(this.b, blockposition, resultPath);
+                synchronized(this.positionSearchCache) {
+                    SearchCacheEntry oldEntry = this.positionSearchCache.put(type, entry);
+                    if(oldEntry != null) {
+                        oldEntry.cleanup();
+                    }
+                }
+            }
+        }
+        return resultPath;
+    }
+
+    @Override
+    public PathEntity a(double d0, double d1, double d2, PositionPathSearchType type) {
+        return this.a(new BlockPosition(MathHelper.floor(d0), (int) d1, MathHelper.floor(d2)), type);
+    }
+
+    @Override
+    public boolean a(double d0, double d1, double d2, double d3, PositionPathSearchType type) {
+        PathEntity pathentity = this.a((double) MathHelper.floor(d0), (double) ((int) d1), (double) MathHelper.floor(d2), type);
+
+        return this.a(pathentity, d3);
+    }
+
+    public void cleanUpExpiredSearches() {
+        this.cleanUpDelay++;
+        if(this.cleanUpDelay > 100) {
+            this.cleanUpDelay = 0;
+            synchronized(this.searchCache) {
+                Iterator<Entry<UUID, SearchCacheEntry>> iterator = this.searchCache.entrySet().iterator();
+                while(iterator.hasNext()) {
+                    SearchCacheEntry entry = iterator.next().getValue();
+                    if(entry.hasExpired()) {
+                        iterator.remove();
+                        entry.cleanup();
+                    } else {
+                        break;
+                    }
+                }
+            }
+            synchronized(this.positionSearchCache) {
+                Iterator<Entry<PositionPathSearchType, SearchCacheEntryPosition>> iterator = this.positionSearchCache.entrySet().iterator();
+                while(iterator.hasNext()) {
+                    SearchCacheEntryPosition entry = iterator.next().getValue();
+                    if(entry.hasExpired()) {
+                        iterator.remove();
+                        entry.cleanup();
+                    } else {
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    private boolean offloadSearches() {
+        return Migot.getConfig().isPathSearchOffloadedFor(this.b);
+    }
+}
diff --git a/src/main/java/de/minetick/pathsearch/PathSearchJob.java b/src/main/java/de/minetick/pathsearch/PathSearchJob.java
new file mode 100644
index 0000000..8c03d2a
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/PathSearchJob.java
@@ -0,0 +1,52 @@
+package de.minetick.pathsearch;
+
+import java.util.concurrent.Callable;
+
+import net.minecraft.server.ChunkCache;
+import net.minecraft.server.EntityCreature;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.NavigationAbstract;
+import net.minecraft.server.PathEntity;
+
+public abstract class PathSearchJob implements Callable<PathSearchJob> {
+
+    public NavigationAbstract navigation;
+    protected ChunkCache chunkCache;
+    protected boolean issued;
+    private int hashCode;
+    protected PathEntity pathEntity;
+
+    public PathSearchJob(NavigationAbstract navigation) {
+        this.navigation = navigation;
+        this.hashCode = this.navigation.hashCode();
+        this.issued = false;
+        this.chunkCache = this.navigation.createChunkCache(this.isEntitySearch());
+    }
+
+    protected boolean isEntitySearch() {
+        return false;
+    }
+
+    public void cleanup() {
+        this.navigation = null;
+        this.chunkCache = null;
+        this.pathEntity = null;
+    }
+
+    @Override
+    public int hashCode() {
+        return this.hashCode;
+    }
+
+    public final int getSearchHash() {
+        return this.hashCode;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if(o == null || !(o instanceof PathSearchJob)) {
+            return false;
+        }
+        return this.hashCode() == ((PathSearchJob)o).hashCode();
+    }
+}
diff --git a/src/main/java/de/minetick/pathsearch/PathSearchJobEntity.java b/src/main/java/de/minetick/pathsearch/PathSearchJobEntity.java
new file mode 100644
index 0000000..6d6ee36
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/PathSearchJobEntity.java
@@ -0,0 +1,56 @@
+package de.minetick.pathsearch;
+
+import java.util.UUID;
+
+import de.minetick.pathsearch.cache.SearchCacheEntry;
+import de.minetick.pathsearch.cache.SearchCacheEntryEntity;
+
+import net.minecraft.server.ChunkCache;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityCreature;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.NavigationAbstract;
+import net.minecraft.server.PathEntity;
+
+public class PathSearchJobEntity extends PathSearchJob {
+
+    public Entity target;
+
+    public PathSearchJobEntity(NavigationAbstract navigation, Entity target) {
+        super(navigation);
+        this.target = target;
+    }
+
+    @Override
+    public PathSearchJob call() throws Exception {
+        if(!this.issued) {
+            this.issued = true;
+            this.pathEntity = this.navigation.doPathSearch(this.chunkCache, this.target);
+            this.navigation.setSearchResult(this);
+            this.cleanup();
+        }
+        return this;
+    }
+
+    @Override
+    protected boolean isEntitySearch() {
+        return true;
+    }
+    
+    @Override
+    public void cleanup() {
+        super.cleanup();
+        this.target = null;
+    }
+
+    public UUID getCacheEntryKey() {
+        return this.target.getUniqueID();
+    }
+
+    public SearchCacheEntry getCacheEntryValue() {
+        if(this.pathEntity != null) {
+            return new SearchCacheEntryEntity(this.navigation.getEntity(), this.target, this.pathEntity);
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/de/minetick/pathsearch/PathSearchJobPosition.java b/src/main/java/de/minetick/pathsearch/PathSearchJobPosition.java
new file mode 100644
index 0000000..64fa3a5
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/PathSearchJobPosition.java
@@ -0,0 +1,61 @@
+package de.minetick.pathsearch;
+
+import de.minetick.pathsearch.cache.SearchCacheEntryPosition;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.NavigationAbstract;
+import net.minecraft.server.PathEntity;
+
+public class PathSearchJobPosition extends PathSearchJob {
+
+    private PositionPathSearchType type;
+    private BlockPosition blockposition;
+
+    public PathSearchJobPosition(NavigationAbstract navigation, BlockPosition blockposition, PositionPathSearchType type) {
+        super(navigation);
+        this.blockposition = blockposition;
+        this.type = type;
+    }
+
+    @Override
+    public PathSearchJob call() throws Exception {
+        if(!this.issued) {
+            this.issued = true;
+            this.pathEntity = this.navigation.doPathSearch(this.chunkCache, this.blockposition);
+            this.navigation.setSearchResult(this);
+            this.cleanup();
+        }
+        return this;
+    }
+
+    public PositionPathSearchType getCacheEntryKey() {
+        return this.type;
+    }
+
+    public SearchCacheEntryPosition getCacheEntryValue() {
+        if(this.pathEntity != null) {
+            return new SearchCacheEntryPosition(this.navigation.getEntity(), this.blockposition, this.pathEntity);
+        }
+        return null;
+    }
+
+    @Override
+    public int hashCode() {
+        return this.type.hashCode() ^ (super.hashCode() << 4);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if(o == null || !(o instanceof PathSearchJobPosition)) {
+            return false;
+        }
+        PathSearchJobPosition other = (PathSearchJobPosition) o;
+        return this.type.equals(other.type) && this.hashCode() == other.hashCode();
+    }
+
+    @Override
+    public void cleanup() {
+        super.cleanup();
+        this.blockposition = null;
+    }
+}
diff --git a/src/main/java/de/minetick/pathsearch/PathSearchThrottlerThread.java b/src/main/java/de/minetick/pathsearch/PathSearchThrottlerThread.java
new file mode 100644
index 0000000..fd71257
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/PathSearchThrottlerThread.java
@@ -0,0 +1,101 @@
+package de.minetick.pathsearch;
+
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map.Entry;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import de.minetick.MigotThreadFactory;
+
+public class PathSearchThrottlerThread extends ThreadPoolExecutor {
+
+    private int queueLimit;
+    private LinkedHashMap<PathSearchJob, PathSearchJob> filter;
+    private HashSet<Integer> activeSearchHashes;
+    private static PathSearchThrottlerThread instance;
+
+    public PathSearchThrottlerThread(int poolSize) {
+        super(poolSize, poolSize, 1L, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), new MigotThreadFactory(Thread.MIN_PRIORITY, "Migot_PathFinder"));
+        instance = this;
+        adjustPoolSize(poolSize);
+        this.filter = new LinkedHashMap<PathSearchJob, PathSearchJob>();
+        this.activeSearchHashes = new HashSet<Integer>();
+    }
+
+    public boolean queuePathSearch(PathSearchJob newJob) {
+        boolean jobHasBeenQueued = false;
+        if(newJob != null) {
+            synchronized(this.filter) {
+                if(this.filter.containsKey(newJob) || this.filter.size() < 1000) {
+                    jobHasBeenQueued = true;
+                    PathSearchJob previousJob = this.filter.put(newJob, newJob);
+                    if(previousJob != null) {
+                        previousJob.cleanup();
+                    }
+                }
+            }
+        }
+        PathSearchJob jobToExecute = null;
+        synchronized(this.filter) {
+            Iterator<Entry<PathSearchJob, PathSearchJob>> iter = this.filter.entrySet().iterator();
+            while(iter.hasNext() && this.getQueue().size() < this.queueLimit) {
+                jobToExecute = iter.next().getValue();
+                if(!this.activeSearchHashes.contains(jobToExecute.getSearchHash())) {
+                    iter.remove();
+                    if(jobToExecute != null) {
+                        this.activeSearchHashes.add(jobToExecute.getSearchHash());
+                        this.submit(jobToExecute);
+                    }
+                    if(newJob != null) {
+                        break;
+                    }
+                }
+            }
+        }
+        return jobHasBeenQueued;
+    }
+
+    @Override
+    public void shutdown() {
+        this.getQueue().clear();
+        super.shutdown();
+    }
+
+    @Override
+    protected void afterExecute(Runnable runnable, Throwable throwable) {
+        super.afterExecute(runnable, throwable);
+        if(runnable instanceof FutureTask) {
+            FutureTask<PathSearchJob> task = (FutureTask<PathSearchJob>) runnable;
+            PathSearchJob job = null;
+            try {
+                job = task.get();
+            } catch (InterruptedException e) {
+            } catch (ExecutionException e) {
+            }
+            if(job != null) {
+                synchronized(this.filter) {
+                    this.activeSearchHashes.remove(job.getSearchHash());
+                }
+            }
+        }
+        this.queuePathSearch(null);
+    }
+
+    public static void adjustPoolSize(int size) {
+        if(instance != null) {
+            if(size > instance.getMaximumPoolSize()) {
+                instance.setMaximumPoolSize(size);
+                instance.setCorePoolSize(size);
+            } else if(size < instance.getMaximumPoolSize()) {
+                instance.setCorePoolSize(size);
+                instance.setMaximumPoolSize(size);
+            }
+            instance.queueLimit = size * 8;
+        }
+    }
+}
diff --git a/src/main/java/de/minetick/pathsearch/PositionPathSearchType.java b/src/main/java/de/minetick/pathsearch/PositionPathSearchType.java
new file mode 100644
index 0000000..22e0b28
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/PositionPathSearchType.java
@@ -0,0 +1,16 @@
+package de.minetick.pathsearch;
+
+public enum PositionPathSearchType {
+    ANYOTHER,
+    AVOIDTARGET,
+    FLEESUN,
+    GOTOTARGET,
+    MOVEINDOORS,
+    MOVETHROUGHVILLAGE,
+    MOVETOWARDSRESTRICTION,
+    MOVETOWARDSTARGET,
+    PANIC,
+    PLAY,
+    RANDOMSTROLL,
+    TAME;
+}
diff --git a/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntry.java b/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntry.java
new file mode 100644
index 0000000..859f0cd
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntry.java
@@ -0,0 +1,76 @@
+package de.minetick.pathsearch.cache;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.PathEntity;
+import net.minecraft.server.PathPoint;
+
+public class SearchCacheEntry {
+    protected long tick;
+    protected BlockPosition positionStart;
+    protected BlockPosition positionTarget;
+    protected EntityInsentient entity;
+    private PathEntity path;
+
+    public SearchCacheEntry(EntityInsentient entity, PathEntity path) {
+        this.entity = entity;
+        this.positionStart = this.getBlockPosition(this.entity);
+        this.path = path;
+        this.tick = this.getCurrentTick();
+    }
+
+    protected int getCurrentTick() {
+        return MinecraftServer.getServer().at();
+    }
+
+    protected BlockPosition getBlockPosition(Entity entity) {
+        return new BlockPosition(entity).up();
+    }
+
+    protected BlockPosition getBlockPosition(int x, int y, int z) {
+        return new BlockPosition(x, y, z);
+    }
+
+    public boolean isStillValid() {
+        return this.didSearchSucceed() && (this.getCurrentTick() - this.tick < 10);
+    }
+
+    public PathEntity getPathEntity() {
+        return this.path;
+    }
+
+    public boolean hasExpired() {
+        return !this.entity.isAlive() || !this.entity.valid  || (this.getCurrentTick() - this.tick) > 100;
+    }
+
+    public boolean didSearchSucceed() {
+        return this.path != null;
+    }
+
+    public PathEntity getAdjustedPathEntity() {
+        if(this.path != null && (this.path.e() < this.path.d() - 1)) {
+            PathPoint pathpoint = this.path.a(this.path.e());
+            double currentDist = this.entity.e(pathpoint.a, pathpoint.b, pathpoint.c);
+            while(this.path.e() < this.path.d() - 1) {
+                pathpoint = this.path.a(this.path.e() + 1);
+                double nextDist = this.entity.e(pathpoint.a, pathpoint.b, pathpoint.c);
+                if(nextDist < currentDist) {
+                    currentDist = nextDist;
+                    this.path.a();
+                } else {
+                    break;
+                }
+            }
+        }
+        return this.path;
+    }
+
+    public void cleanup() {
+        this.positionStart = null;
+        this.positionTarget = null;
+        this.entity = null;
+        this.path = null;
+    }
+}
diff --git a/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntryEntity.java b/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntryEntity.java
new file mode 100644
index 0000000..2b02066
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntryEntity.java
@@ -0,0 +1,31 @@
+package de.minetick.pathsearch.cache;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.PathEntity;
+
+public class SearchCacheEntryEntity extends SearchCacheEntry {
+
+    private Entity target;
+
+    public SearchCacheEntryEntity(EntityInsentient entity, Entity target, PathEntity path) {
+        super(entity, path);
+        this.target = target;
+        this.positionTarget = this.getBlockPosition(this.target);
+    }
+
+    @Override
+    public boolean isStillValid() {
+        if(super.isStillValid()) {
+            return this.getBlockPosition(this.target).equals(this.positionTarget);
+        }
+        return false;
+    }
+    
+    @Override
+    public void cleanup() {
+        super.cleanup();
+        this.target = null;
+    }
+}
diff --git a/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntryPosition.java b/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntryPosition.java
new file mode 100644
index 0000000..e97a474
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntryPosition.java
@@ -0,0 +1,21 @@
+package de.minetick.pathsearch.cache;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.PathEntity;
+
+public class SearchCacheEntryPosition extends SearchCacheEntry {
+    
+    public SearchCacheEntryPosition(EntityInsentient entity, BlockPosition blockposition, PathEntity path) {
+        super(entity, path);
+        this.positionTarget = blockposition;
+    }
+
+    @Override
+    public boolean isStillValid() {
+        if(super.isStillValid()) {
+            return this.getBlockPosition(this.entity).equals(this.positionStart);
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 62b945d..eb5c7c2 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -938,9 +938,15 @@ public abstract class Entity implements ICommandListener {
     }
 
     public boolean ab() {
-        return this.world.a(this.getBoundingBox().grow(-0.10000000149011612D, -0.4000000059604645D, -0.10000000149011612D), Material.LAVA);
+    // Migot start
+        return this.ab(this.world);
     }
 
+    public boolean ab(IBlockAccess iblockaccess) {
+        return this.world.a(iblockaccess, this.getBoundingBox().grow(-0.10000000149011612D, -0.4000000059604645D, -0.10000000149011612D), Material.LAVA);
+    }
+    // Migot end
+
     public void a(float f, float f1, float f2) {
         float f3 = f * f + f1 * f1;
 
diff --git a/src/main/java/net/minecraft/server/EntityInsentient.java b/src/main/java/net/minecraft/server/EntityInsentient.java
index 44b0fe4..0ec0b02 100644
--- a/src/main/java/net/minecraft/server/EntityInsentient.java
+++ b/src/main/java/net/minecraft/server/EntityInsentient.java
@@ -13,6 +13,8 @@ import org.bukkit.event.entity.EntityUnleashEvent;
 import org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;
 // CraftBukkit end
 
+import de.minetick.pathsearch.MigotNavigation; // Migot
+
 public abstract class EntityInsentient extends EntityLiving {
 
     public int a_;
@@ -60,7 +62,7 @@ public abstract class EntityInsentient extends EntityLiving {
     }
 
     protected NavigationAbstract b(World world) {
-        return new Navigation(this, world);
+        return new MigotNavigation(this, world); // Migot
     }
 
     public ControllerLook getControllerLook() {
@@ -460,6 +462,7 @@ public abstract class EntityInsentient extends EntityLiving {
 
     protected final void doTick() {
         ++this.ticksFarFromPlayer;
+        this.navigation.cleanUpExpiredSearches(); // Migot
         this.world.methodProfiler.a("checkDespawn");
         this.D();
         this.world.methodProfiler.b();
diff --git a/src/main/java/net/minecraft/server/NavigationAbstract.java b/src/main/java/net/minecraft/server/NavigationAbstract.java
index d5eaa24..287533c 100644
--- a/src/main/java/net/minecraft/server/NavigationAbstract.java
+++ b/src/main/java/net/minecraft/server/NavigationAbstract.java
@@ -3,6 +3,12 @@ package net.minecraft.server;
 import java.util.Iterator;
 import java.util.List;
 
+// Migot start
+import de.minetick.pathsearch.PathSearchJobEntity;
+import de.minetick.pathsearch.PathSearchJobPosition;
+import de.minetick.pathsearch.PositionPathSearchType;
+// Migot end
+
 public abstract class NavigationAbstract {
 
     protected EntityInsentient b;
@@ -219,4 +225,51 @@ public abstract class NavigationAbstract {
     protected void d() {}
 
     protected abstract boolean a(Vec3D vec3d, Vec3D vec3d1, int i, int j, int k);
+
+    // Migot start
+    public EntityInsentient getEntity() {
+        return this.b;
+    }
+
+    @Override
+    public int hashCode() {
+        return this.b.getUniqueID().hashCode();
+    }
+
+    public void cleanUpExpiredSearches() {}
+
+    public void setSearchResult(PathSearchJobEntity pathSearch) { }
+
+    public void setSearchResult(PathSearchJobPosition pathSearch) { }
+
+    public boolean a(double d0, double d1, double d2, double d3, PositionPathSearchType type) {
+        return this.a(d0, d1, d2, d3);
+    }
+
+    public PathEntity a(double d0, double d1, double d2, PositionPathSearchType type) {
+        return this.a(d0, d1, d2);
+    }
+
+    public ChunkCache createChunkCache(boolean forEntitySearch) {
+        if (this.b()) {
+            float f = this.i();
+            BlockPosition blockposition1 = new BlockPosition(this.b);
+            int i = (int) (f + (forEntitySearch ? 16.0F : 8.0F));
+            return new ChunkCache(this.c, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+        }
+        return null;
+    }
+
+    public PathEntity doPathSearch(ChunkCache chunkcache, BlockPosition blockposition) {
+        if (this.b()) {
+            float f = this.i();
+            return this.j.a((IBlockAccess) chunkcache, (Entity) this.b, blockposition, f);
+        }
+        return null;
+    }
+
+    public PathEntity doPathSearch(ChunkCache chunkcache, Entity entity) {
+        return this.doPathSearch(chunkcache, (new BlockPosition(entity)).up());
+    }
+    // Migot end
 }
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalAvoidTarget.java b/src/main/java/net/minecraft/server/PathfinderGoalAvoidTarget.java
index cb32be5..8201e32 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalAvoidTarget.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalAvoidTarget.java
@@ -55,7 +55,7 @@ public class PathfinderGoalAvoidTarget<T extends Entity> extends PathfinderGoal
             } else if (this.b.e(vec3d.a, vec3d.b, vec3d.c) < this.b.h(this.a)) {
                 return false;
             } else {
-                this.g = this.h.a(vec3d.a, vec3d.b, vec3d.c);
+                this.g = this.h.a(vec3d.a, vec3d.b, vec3d.c, de.minetick.pathsearch.PositionPathSearchType.AVOIDTARGET); // Migot
                 return this.g == null ? false : this.g.b(vec3d);
             }
         }
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalFleeSun.java b/src/main/java/net/minecraft/server/PathfinderGoalFleeSun.java
index 3d83cc3..f32b29f 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalFleeSun.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalFleeSun.java
@@ -44,7 +44,7 @@ public class PathfinderGoalFleeSun extends PathfinderGoal {
     }
 
     public void c() {
-        this.a.getNavigation().a(this.b, this.c, this.d, this.e);
+        this.a.getNavigation().a(this.b, this.c, this.d, this.e, de.minetick.pathsearch.PositionPathSearchType.FLEESUN); // Migot
     }
 
     private Vec3D f() {
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalGotoTarget.java b/src/main/java/net/minecraft/server/PathfinderGoalGotoTarget.java
index 3d19e52..deba58a 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalGotoTarget.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalGotoTarget.java
@@ -34,7 +34,7 @@ public abstract class PathfinderGoalGotoTarget extends PathfinderGoal {
     }
 
     public void c() {
-        this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d);
+        this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d, de.minetick.pathsearch.PositionPathSearchType.GOTOTARGET); // Migot
         this.e = 0;
         this.f = this.c.bc().nextInt(this.c.bc().nextInt(1200) + 1200) + 1200;
     }
@@ -46,7 +46,7 @@ public abstract class PathfinderGoalGotoTarget extends PathfinderGoal {
             this.g = false;
             ++this.e;
             if (this.e % 40 == 0) {
-                this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d);
+                this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d, de.minetick.pathsearch.PositionPathSearchType.GOTOTARGET); // Migot
             }
         } else {
             this.g = true;
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalMoveIndoors.java b/src/main/java/net/minecraft/server/PathfinderGoalMoveIndoors.java
index b3402fb..841c07f 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalMoveIndoors.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalMoveIndoors.java
@@ -50,10 +50,10 @@ public class PathfinderGoalMoveIndoors extends PathfinderGoal {
             Vec3D vec3d = RandomPositionGenerator.a(this.a, 14, 3, new Vec3D((double) i + 0.5D, (double) j, (double) k + 0.5D));
 
             if (vec3d != null) {
-                this.a.getNavigation().a(vec3d.a, vec3d.b, vec3d.c, 1.0D);
+                this.a.getNavigation().a(vec3d.a, vec3d.b, vec3d.c, 1.0D, de.minetick.pathsearch.PositionPathSearchType.MOVEINDOORS); // Migot
             }
         } else {
-            this.a.getNavigation().a((double) i + 0.5D, (double) j, (double) k + 0.5D, 1.0D);
+            this.a.getNavigation().a((double) i + 0.5D, (double) j, (double) k + 0.5D, 1.0D, de.minetick.pathsearch.PositionPathSearchType.MOVEINDOORS); // Migot
         }
 
     }
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalMoveThroughVillage.java b/src/main/java/net/minecraft/server/PathfinderGoalMoveThroughVillage.java
index 3755944..3b34c8b 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalMoveThroughVillage.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalMoveThroughVillage.java
@@ -52,7 +52,7 @@ public class PathfinderGoalMoveThroughVillage extends PathfinderGoal {
                             return false;
                         } else {
                             navigation.b(false);
-                            this.c = this.a.getNavigation().a(vec3d.a, vec3d.b, vec3d.c);
+                            this.c = this.a.getNavigation().a(vec3d.a, vec3d.b, vec3d.c, de.minetick.pathsearch.PositionPathSearchType.MOVETHROUGHVILLAGE); // Migot
                             navigation.b(flag);
                             return this.c != null;
                         }
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsRestriction.java b/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsRestriction.java
index 7d2a14b..dfd9640 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsRestriction.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsRestriction.java
@@ -37,6 +37,6 @@ public class PathfinderGoalMoveTowardsRestriction extends PathfinderGoal {
     }
 
     public void c() {
-        this.a.getNavigation().a(this.b, this.c, this.d, this.e);
+        this.a.getNavigation().a(this.b, this.c, this.d, this.e, de.minetick.pathsearch.PositionPathSearchType.MOVETOWARDSRESTRICTION); // Migot
     }
 }
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsTarget.java b/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsTarget.java
index 97bf754..17ed32c 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsTarget.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsTarget.java
@@ -46,6 +46,6 @@ public class PathfinderGoalMoveTowardsTarget extends PathfinderGoal {
     }
 
     public void c() {
-        this.a.getNavigation().a(this.c, this.d, this.e, this.f);
+        this.a.getNavigation().a(this.c, this.d, this.e, this.f, de.minetick.pathsearch.PositionPathSearchType.MOVETOWARDSTARGET); // Migot
     }
 }
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalPanic.java b/src/main/java/net/minecraft/server/PathfinderGoalPanic.java
index 30907ef..bd7670e 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalPanic.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalPanic.java
@@ -32,7 +32,7 @@ public class PathfinderGoalPanic extends PathfinderGoal {
     }
 
     public void c() {
-        this.b.getNavigation().a(this.c, this.d, this.e, this.a);
+        this.b.getNavigation().a(this.c, this.d, this.e, this.a, de.minetick.pathsearch.PositionPathSearchType.PANIC); // Migot
     }
 
     public boolean b() {
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalPlay.java b/src/main/java/net/minecraft/server/PathfinderGoalPlay.java
index fc2f47b..0b0ac7f 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalPlay.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalPlay.java
@@ -81,7 +81,7 @@ public class PathfinderGoalPlay extends PathfinderGoal {
                 return;
             }
 
-            this.a.getNavigation().a(vec3d.a, vec3d.b, vec3d.c, this.c);
+            this.a.getNavigation().a(vec3d.a, vec3d.b, vec3d.c, this.c, de.minetick.pathsearch.PositionPathSearchType.PLAY); // Migot
         }
 
     }
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalRandomStroll.java b/src/main/java/net/minecraft/server/PathfinderGoalRandomStroll.java
index d7a5fb6..14d664b 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalRandomStroll.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalRandomStroll.java
@@ -50,7 +50,7 @@ public class PathfinderGoalRandomStroll extends PathfinderGoal {
     }
 
     public void c() {
-        this.a.getNavigation().a(this.b, this.c, this.d, this.e);
+        this.a.getNavigation().a(this.b, this.c, this.d, this.e, de.minetick.pathsearch.PositionPathSearchType.RANDOMSTROLL); // Migot
     }
 
     public void f() {
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalTame.java b/src/main/java/net/minecraft/server/PathfinderGoalTame.java
index 123e657..12ab67f 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalTame.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalTame.java
@@ -32,7 +32,7 @@ public class PathfinderGoalTame extends PathfinderGoal {
     }
 
     public void c() {
-        this.entity.getNavigation().a(this.c, this.d, this.e, this.b);
+        this.entity.getNavigation().a(this.c, this.d, this.e, this.b, de.minetick.pathsearch.PositionPathSearchType.TAME); // Migot
     }
 
     public boolean b() {
diff --git a/src/main/java/net/minecraft/server/PathfinderNormal.java b/src/main/java/net/minecraft/server/PathfinderNormal.java
index 0a14c9d..503518e 100644
--- a/src/main/java/net/minecraft/server/PathfinderNormal.java
+++ b/src/main/java/net/minecraft/server/PathfinderNormal.java
@@ -158,8 +158,8 @@ public class PathfinderNormal extends PathfinderAbstract {
                             flag3 = true;
                         }
 
-                        if (entity.world.getType(blockposition_mutableblockposition).getBlock() instanceof BlockMinecartTrackAbstract) {
-                            if (!(entity.world.getType(blockposition).getBlock() instanceof BlockMinecartTrackAbstract) && !(entity.world.getType(blockposition.down()).getBlock() instanceof BlockMinecartTrackAbstract)) {
+                        if (iblockaccess.getType(blockposition_mutableblockposition).getBlock() instanceof BlockMinecartTrackAbstract) { // Migot - use @iblockaccess instead of entity.world
+                            if (!(iblockaccess.getType(blockposition).getBlock() instanceof BlockMinecartTrackAbstract) && !(iblockaccess.getType(blockposition.down()).getBlock() instanceof BlockMinecartTrackAbstract)) {  // Migot - use @iblockaccess instead of entity.world
                                 return -3;
                             }
                         } else if (!block.b(iblockaccess, blockposition_mutableblockposition) && (!flag1 || !(block instanceof BlockDoor) || block.getMaterial() != Material.WOOD)) {
@@ -177,7 +177,7 @@ public class PathfinderNormal extends PathfinderAbstract {
                                 return 0;
                             }
 
-                            if (!entity.ab()) {
+                            if (!entity.ab(iblockaccess)) { // Migot
                                 return -2;
                             }
                         }
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 3c97b0a..5430baf 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -1831,6 +1831,12 @@ public abstract class World implements IBlockAccess {
     }
 
     public boolean a(AxisAlignedBB axisalignedbb, Material material) {
+    // Migot start
+        return this.a(this, axisalignedbb, material);
+    }
+
+    public boolean a(IBlockAccess iblockaccess, AxisAlignedBB axisalignedbb, Material material) {
+    // Migot end
         int i = MathHelper.floor(axisalignedbb.a);
         int j = MathHelper.floor(axisalignedbb.d + 1.0D);
         int k = MathHelper.floor(axisalignedbb.b);
@@ -1842,7 +1848,7 @@ public abstract class World implements IBlockAccess {
         for (int k1 = i; k1 < j; ++k1) {
             for (int l1 = k; l1 < l; ++l1) {
                 for (int i2 = i1; i2 < j1; ++i2) {
-                    if (this.getType(blockposition_mutableblockposition.c(k1, l1, i2)).getBlock().getMaterial() == material) {
+                    if (iblockaccess.getType(blockposition_mutableblockposition.c(k1, l1, i2)).getBlock().getMaterial() == material) { // Migot
                         return true;
                     }
                 }
diff --git a/src/main/resources/configurations/migot.yml b/src/main/resources/configurations/migot.yml
index 14cb19d..5494808 100644
--- a/src/main/resources/configurations/migot.yml
+++ b/src/main/resources/configurations/migot.yml
@@ -1 +1,27 @@
 general-settings:
+async-pathsearches:
+    enabled: true
+    threadPoolSize: 1
+    minimumDistanceToTarget: 0.0
+    entities:
+    - BAT
+    - BLAZE
+    - CHICKEN
+    - COW
+    - CREEPER
+    - ENDERMAN
+    - HORSE
+    - IRON_GOLEM
+    - MAGMA_CUBE
+    - MUSHROOM_COW
+    - PIG
+    - PIG_ZOMBIE
+    - RABBIT
+    - SHEEP
+    - SKELETON
+    - SILVERFISH
+    - SLIME
+    - SNOWMAN
+    - SQUID
+    - WITCH
+    - ZOMBIE
-- 
2.6.2.windows.1

