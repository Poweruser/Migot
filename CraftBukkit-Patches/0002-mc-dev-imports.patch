From 53f6a9f493204f2c521e776e3faff4252b1ba69b Mon Sep 17 00:00:00 2001
From: md_5 <md_5@live.com.au>
Date: Sun, 1 Dec 2013 15:10:48 +1100
Subject: [PATCH] mc-dev imports

Imported files which are only modified by Spigot, not upstream. Files here should be completely unmodified aside from trivial changes such as adding throws statements to ensure proper compilation. You may need to add unrelated files in order to ensure a compilable result in the face of synthetic methods.

diff --git a/src/main/java/net/minecraft/server/AttributeRanged.java b/src/main/java/net/minecraft/server/AttributeRanged.java
new file mode 100644
index 0000000..13602f0
--- /dev/null
+++ b/src/main/java/net/minecraft/server/AttributeRanged.java
@@ -0,0 +1,35 @@
+package net.minecraft.server;
+
+public class AttributeRanged extends AttributeBase {
+
+    private final double a;
+    private final double b;
+    private String c;
+
+    public AttributeRanged(IAttribute iattribute, String s, double d0, double d1, double d2) {
+        super(iattribute, s, d0);
+        this.a = d1;
+        this.b = d2;
+        if (d1 > d2) {
+            throw new IllegalArgumentException("Minimum value cannot be bigger than maximum value!");
+        } else if (d0 < d1) {
+            throw new IllegalArgumentException("Default value cannot be lower than minimum value!");
+        } else if (d0 > d2) {
+            throw new IllegalArgumentException("Default value cannot be bigger than maximum value!");
+        }
+    }
+
+    public AttributeRanged a(String s) {
+        this.c = s;
+        return this;
+    }
+
+    public String g() {
+        return this.c;
+    }
+
+    public double a(double d0) {
+        d0 = MathHelper.a(d0, this.a, this.b);
+        return d0;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockAnvil.java b/src/main/java/net/minecraft/server/BlockAnvil.java
new file mode 100644
index 0000000..43b1d00
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockAnvil.java
@@ -0,0 +1,108 @@
+package net.minecraft.server;
+
+import com.google.common.base.Predicate;
+
+public class BlockAnvil extends BlockFalling {
+
+    public static final BlockStateDirection FACING = BlockStateDirection.of("facing", (Predicate) EnumDirection.EnumDirectionLimit.HORIZONTAL);
+    public static final BlockStateInteger DAMAGE = BlockStateInteger.of("damage", 0, 2);
+
+    protected BlockAnvil() {
+        super(Material.HEAVY);
+        this.j(this.blockStateList.getBlockData().set(BlockAnvil.FACING, EnumDirection.NORTH).set(BlockAnvil.DAMAGE, Integer.valueOf(0)));
+        this.e(0);
+        this.a(CreativeModeTab.c);
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public IBlockData getPlacedState(World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2, int i, EntityLiving entityliving) {
+        EnumDirection enumdirection1 = entityliving.getDirection().e();
+
+        return super.getPlacedState(world, blockposition, enumdirection, f, f1, f2, i, entityliving).set(BlockAnvil.FACING, enumdirection1).set(BlockAnvil.DAMAGE, Integer.valueOf(i >> 2));
+    }
+
+    public boolean interact(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman, EnumDirection enumdirection, float f, float f1, float f2) {
+        if (!world.isClientSide) {
+            entityhuman.openTileEntity(new BlockAnvil.TileEntityContainerAnvil(world, blockposition));
+        }
+
+        return true;
+    }
+
+    public int getDropData(IBlockData iblockdata) {
+        return ((Integer) iblockdata.get(BlockAnvil.DAMAGE)).intValue();
+    }
+
+    public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        EnumDirection enumdirection = (EnumDirection) iblockaccess.getType(blockposition).get(BlockAnvil.FACING);
+
+        if (enumdirection.k() == EnumDirection.EnumAxis.X) {
+            this.a(0.0F, 0.0F, 0.125F, 1.0F, 1.0F, 0.875F);
+        } else {
+            this.a(0.125F, 0.0F, 0.0F, 0.875F, 1.0F, 1.0F);
+        }
+
+    }
+
+    protected void a(EntityFallingBlock entityfallingblock) {
+        entityfallingblock.a(true);
+    }
+
+    public void a_(World world, BlockPosition blockposition) {
+        world.triggerEffect(1022, blockposition, 0);
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        return this.getBlockData().set(BlockAnvil.FACING, EnumDirection.fromType2(i & 3)).set(BlockAnvil.DAMAGE, Integer.valueOf((i & 15) >> 2));
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        byte b0 = 0;
+        int i = b0 | ((EnumDirection) iblockdata.get(BlockAnvil.FACING)).b();
+
+        i |= ((Integer) iblockdata.get(BlockAnvil.DAMAGE)).intValue() << 2;
+        return i;
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockAnvil.FACING, BlockAnvil.DAMAGE});
+    }
+
+    public static class TileEntityContainerAnvil implements ITileEntityContainer {
+
+        private final World a;
+        private final BlockPosition b;
+
+        public TileEntityContainerAnvil(World world, BlockPosition blockposition) {
+            this.a = world;
+            this.b = blockposition;
+        }
+
+        public String getName() {
+            return "anvil";
+        }
+
+        public boolean hasCustomName() {
+            return false;
+        }
+
+        public IChatBaseComponent getScoreboardDisplayName() {
+            return new ChatMessage(Blocks.ANVIL.a() + ".name", new Object[0]);
+        }
+
+        public Container createContainer(PlayerInventory playerinventory, EntityHuman entityhuman) {
+            return new ContainerAnvil(playerinventory, this.a, this.b, entityhuman);
+        }
+
+        public String getContainerName() {
+            return "minecraft:anvil";
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockBrewingStand.java b/src/main/java/net/minecraft/server/BlockBrewingStand.java
new file mode 100644
index 0000000..0bb2b50
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockBrewingStand.java
@@ -0,0 +1,119 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+
+public class BlockBrewingStand extends BlockContainer {
+
+    public static final BlockStateBoolean[] HAS_BOTTLE = new BlockStateBoolean[] { BlockStateBoolean.of("has_bottle_0"), BlockStateBoolean.of("has_bottle_1"), BlockStateBoolean.of("has_bottle_2")};
+
+    public BlockBrewingStand() {
+        super(Material.ORE);
+        this.j(this.blockStateList.getBlockData().set(BlockBrewingStand.HAS_BOTTLE[0], Boolean.valueOf(false)).set(BlockBrewingStand.HAS_BOTTLE[1], Boolean.valueOf(false)).set(BlockBrewingStand.HAS_BOTTLE[2], Boolean.valueOf(false)));
+    }
+
+    public String getName() {
+        return LocaleI18n.get("item.brewingStand.name");
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public int b() {
+        return 3;
+    }
+
+    public TileEntity a(World world, int i) {
+        return new TileEntityBrewingStand();
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, Entity entity) {
+        this.a(0.4375F, 0.0F, 0.4375F, 0.5625F, 0.875F, 0.5625F);
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        this.j();
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+    }
+
+    public void j() {
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+    }
+
+    public boolean interact(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman, EnumDirection enumdirection, float f, float f1, float f2) {
+        if (world.isClientSide) {
+            return true;
+        } else {
+            TileEntity tileentity = world.getTileEntity(blockposition);
+
+            if (tileentity instanceof TileEntityBrewingStand) {
+                entityhuman.openContainer((TileEntityBrewingStand) tileentity);
+                entityhuman.b(StatisticList.M);
+            }
+
+            return true;
+        }
+    }
+
+    public void postPlace(World world, BlockPosition blockposition, IBlockData iblockdata, EntityLiving entityliving, ItemStack itemstack) {
+        if (itemstack.hasName()) {
+            TileEntity tileentity = world.getTileEntity(blockposition);
+
+            if (tileentity instanceof TileEntityBrewingStand) {
+                ((TileEntityBrewingStand) tileentity).a(itemstack.getName());
+            }
+        }
+
+    }
+
+    public void remove(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        TileEntity tileentity = world.getTileEntity(blockposition);
+
+        if (tileentity instanceof TileEntityBrewingStand) {
+            InventoryUtils.dropInventory(world, blockposition, (TileEntityBrewingStand) tileentity);
+        }
+
+        super.remove(world, blockposition, iblockdata);
+    }
+
+    public Item getDropType(IBlockData iblockdata, Random random, int i) {
+        return Items.BREWING_STAND;
+    }
+
+    public boolean isComplexRedstone() {
+        return true;
+    }
+
+    public int l(World world, BlockPosition blockposition) {
+        return Container.a(world.getTileEntity(blockposition));
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        IBlockData iblockdata = this.getBlockData();
+
+        for (int j = 0; j < 3; ++j) {
+            iblockdata = iblockdata.set(BlockBrewingStand.HAS_BOTTLE[j], Boolean.valueOf((i & 1 << j) > 0));
+        }
+
+        return iblockdata;
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        int i = 0;
+
+        for (int j = 0; j < 3; ++j) {
+            if (((Boolean) iblockdata.get(BlockBrewingStand.HAS_BOTTLE[j])).booleanValue()) {
+                i |= 1 << j;
+            }
+        }
+
+        return i;
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockBrewingStand.HAS_BOTTLE[0], BlockBrewingStand.HAS_BOTTLE[1], BlockBrewingStand.HAS_BOTTLE[2]});
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockFlowerPot.java b/src/main/java/net/minecraft/server/BlockFlowerPot.java
new file mode 100644
index 0000000..fd77047
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockFlowerPot.java
@@ -0,0 +1,432 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BlockFlowerPot extends BlockContainer {
+
+    public static final BlockStateInteger LEGACY_DATA = BlockStateInteger.of("legacy_data", 0, 15);
+    public static final BlockStateEnum<BlockFlowerPot.EnumFlowerPotContents> CONTENTS = BlockStateEnum.of("contents", BlockFlowerPot.EnumFlowerPotContents.class);
+
+    public BlockFlowerPot() {
+        super(Material.ORIENTABLE);
+        this.j(this.blockStateList.getBlockData().set(BlockFlowerPot.CONTENTS, BlockFlowerPot.EnumFlowerPotContents.EMPTY).set(BlockFlowerPot.LEGACY_DATA, Integer.valueOf(0)));
+        this.j();
+    }
+
+    public String getName() {
+        return LocaleI18n.get("item.flowerPot.name");
+    }
+
+    public void j() {
+        float f = 0.375F;
+        float f1 = f / 2.0F;
+
+        this.a(0.5F - f1, 0.0F, 0.5F - f1, 0.5F + f1, f, 0.5F + f1);
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public int b() {
+        return 3;
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean interact(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman, EnumDirection enumdirection, float f, float f1, float f2) {
+        ItemStack itemstack = entityhuman.inventory.getItemInHand();
+
+        if (itemstack != null && itemstack.getItem() instanceof ItemBlock) {
+            TileEntityFlowerPot tileentityflowerpot = this.f(world, blockposition);
+
+            if (tileentityflowerpot == null) {
+                return false;
+            } else if (tileentityflowerpot.b() != null) {
+                return false;
+            } else {
+                Block block = Block.asBlock(itemstack.getItem());
+
+                if (!this.a(block, itemstack.getData())) {
+                    return false;
+                } else {
+                    tileentityflowerpot.a(itemstack.getItem(), itemstack.getData());
+                    tileentityflowerpot.update();
+                    world.notify(blockposition);
+                    entityhuman.b(StatisticList.T);
+                    if (!entityhuman.abilities.canInstantlyBuild && --itemstack.count <= 0) {
+                        entityhuman.inventory.setItem(entityhuman.inventory.itemInHandIndex, (ItemStack) null);
+                    }
+
+                    return true;
+                }
+            }
+        } else {
+            return false;
+        }
+    }
+
+    private boolean a(Block block, int i) {
+        return block != Blocks.YELLOW_FLOWER && block != Blocks.RED_FLOWER && block != Blocks.CACTUS && block != Blocks.BROWN_MUSHROOM && block != Blocks.RED_MUSHROOM && block != Blocks.SAPLING && block != Blocks.DEADBUSH ? block == Blocks.TALLGRASS && i == BlockLongGrass.EnumTallGrassType.FERN.a() : true;
+    }
+
+    public int getDropData(World world, BlockPosition blockposition) {
+        TileEntityFlowerPot tileentityflowerpot = this.f(world, blockposition);
+
+        return tileentityflowerpot != null && tileentityflowerpot.b() != null ? tileentityflowerpot.c() : 0;
+    }
+
+    public boolean canPlace(World world, BlockPosition blockposition) {
+        return super.canPlace(world, blockposition) && World.a((IBlockAccess) world, blockposition.down());
+    }
+
+    public void doPhysics(World world, BlockPosition blockposition, IBlockData iblockdata, Block block) {
+        if (!World.a((IBlockAccess) world, blockposition.down())) {
+            this.b(world, blockposition, iblockdata, 0);
+            world.setAir(blockposition);
+        }
+
+    }
+
+    public void remove(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        TileEntityFlowerPot tileentityflowerpot = this.f(world, blockposition);
+
+        if (tileentityflowerpot != null && tileentityflowerpot.b() != null) {
+            a(world, blockposition, new ItemStack(tileentityflowerpot.b(), 1, tileentityflowerpot.c()));
+        }
+
+        super.remove(world, blockposition, iblockdata);
+    }
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman) {
+        super.a(world, blockposition, iblockdata, entityhuman);
+        if (entityhuman.abilities.canInstantlyBuild) {
+            TileEntityFlowerPot tileentityflowerpot = this.f(world, blockposition);
+
+            if (tileentityflowerpot != null) {
+                tileentityflowerpot.a((Item) null, 0);
+            }
+        }
+
+    }
+
+    public Item getDropType(IBlockData iblockdata, Random random, int i) {
+        return Items.FLOWER_POT;
+    }
+
+    private TileEntityFlowerPot f(World world, BlockPosition blockposition) {
+        TileEntity tileentity = world.getTileEntity(blockposition);
+
+        return tileentity instanceof TileEntityFlowerPot ? (TileEntityFlowerPot) tileentity : null;
+    }
+
+    public TileEntity a(World world, int i) {
+        Object object = null;
+        int j = 0;
+
+        switch (i) {
+        case 1:
+            object = Blocks.RED_FLOWER;
+            j = BlockFlowers.EnumFlowerVarient.POPPY.b();
+            break;
+
+        case 2:
+            object = Blocks.YELLOW_FLOWER;
+            break;
+
+        case 3:
+            object = Blocks.SAPLING;
+            j = BlockWood.EnumLogVariant.OAK.a();
+            break;
+
+        case 4:
+            object = Blocks.SAPLING;
+            j = BlockWood.EnumLogVariant.SPRUCE.a();
+            break;
+
+        case 5:
+            object = Blocks.SAPLING;
+            j = BlockWood.EnumLogVariant.BIRCH.a();
+            break;
+
+        case 6:
+            object = Blocks.SAPLING;
+            j = BlockWood.EnumLogVariant.JUNGLE.a();
+            break;
+
+        case 7:
+            object = Blocks.RED_MUSHROOM;
+            break;
+
+        case 8:
+            object = Blocks.BROWN_MUSHROOM;
+            break;
+
+        case 9:
+            object = Blocks.CACTUS;
+            break;
+
+        case 10:
+            object = Blocks.DEADBUSH;
+            break;
+
+        case 11:
+            object = Blocks.TALLGRASS;
+            j = BlockLongGrass.EnumTallGrassType.FERN.a();
+            break;
+
+        case 12:
+            object = Blocks.SAPLING;
+            j = BlockWood.EnumLogVariant.ACACIA.a();
+            break;
+
+        case 13:
+            object = Blocks.SAPLING;
+            j = BlockWood.EnumLogVariant.DARK_OAK.a();
+        }
+
+        return new TileEntityFlowerPot(Item.getItemOf((Block) object), j);
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockFlowerPot.CONTENTS, BlockFlowerPot.LEGACY_DATA});
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        return ((Integer) iblockdata.get(BlockFlowerPot.LEGACY_DATA)).intValue();
+    }
+
+    public IBlockData updateState(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
+        BlockFlowerPot.EnumFlowerPotContents blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.EMPTY;
+        TileEntity tileentity = iblockaccess.getTileEntity(blockposition);
+
+        if (tileentity instanceof TileEntityFlowerPot) {
+            TileEntityFlowerPot tileentityflowerpot = (TileEntityFlowerPot) tileentity;
+            Item item = tileentityflowerpot.b();
+
+            if (item instanceof ItemBlock) {
+                int i = tileentityflowerpot.c();
+                Block block = Block.asBlock(item);
+
+                if (block == Blocks.SAPLING) {
+                    switch (BlockFlowerPot.SyntheticClass_1.a[BlockWood.EnumLogVariant.a(i).ordinal()]) {
+                    case 1:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.OAK_SAPLING;
+                        break;
+
+                    case 2:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.SPRUCE_SAPLING;
+                        break;
+
+                    case 3:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.BIRCH_SAPLING;
+                        break;
+
+                    case 4:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.JUNGLE_SAPLING;
+                        break;
+
+                    case 5:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.ACACIA_SAPLING;
+                        break;
+
+                    case 6:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.DARK_OAK_SAPLING;
+                        break;
+
+                    default:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.EMPTY;
+                    }
+                } else if (block == Blocks.TALLGRASS) {
+                    switch (i) {
+                    case 0:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.DEAD_BUSH;
+                        break;
+
+                    case 2:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.FERN;
+                        break;
+
+                    default:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.EMPTY;
+                    }
+                } else if (block == Blocks.YELLOW_FLOWER) {
+                    blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.DANDELION;
+                } else if (block == Blocks.RED_FLOWER) {
+                    switch (BlockFlowerPot.SyntheticClass_1.b[BlockFlowers.EnumFlowerVarient.a(BlockFlowers.EnumFlowerType.RED, i).ordinal()]) {
+                    case 1:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.POPPY;
+                        break;
+
+                    case 2:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.BLUE_ORCHID;
+                        break;
+
+                    case 3:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.ALLIUM;
+                        break;
+
+                    case 4:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.HOUSTONIA;
+                        break;
+
+                    case 5:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.RED_TULIP;
+                        break;
+
+                    case 6:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.ORANGE_TULIP;
+                        break;
+
+                    case 7:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.WHITE_TULIP;
+                        break;
+
+                    case 8:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.PINK_TULIP;
+                        break;
+
+                    case 9:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.OXEYE_DAISY;
+                        break;
+
+                    default:
+                        blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.EMPTY;
+                    }
+                } else if (block == Blocks.RED_MUSHROOM) {
+                    blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.MUSHROOM_RED;
+                } else if (block == Blocks.BROWN_MUSHROOM) {
+                    blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.MUSHROOM_BROWN;
+                } else if (block == Blocks.DEADBUSH) {
+                    blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.DEAD_BUSH;
+                } else if (block == Blocks.CACTUS) {
+                    blockflowerpot_enumflowerpotcontents = BlockFlowerPot.EnumFlowerPotContents.CACTUS;
+                }
+            }
+        }
+
+        return iblockdata.set(BlockFlowerPot.CONTENTS, blockflowerpot_enumflowerpotcontents);
+    }
+
+    static class SyntheticClass_1 {
+
+        static final int[] a;
+        static final int[] b = new int[BlockFlowers.EnumFlowerVarient.values().length];
+
+        static {
+            try {
+                BlockFlowerPot.SyntheticClass_1.b[BlockFlowers.EnumFlowerVarient.POPPY.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror) {
+                ;
+            }
+
+            try {
+                BlockFlowerPot.SyntheticClass_1.b[BlockFlowers.EnumFlowerVarient.BLUE_ORCHID.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror1) {
+                ;
+            }
+
+            try {
+                BlockFlowerPot.SyntheticClass_1.b[BlockFlowers.EnumFlowerVarient.ALLIUM.ordinal()] = 3;
+            } catch (NoSuchFieldError nosuchfielderror2) {
+                ;
+            }
+
+            try {
+                BlockFlowerPot.SyntheticClass_1.b[BlockFlowers.EnumFlowerVarient.HOUSTONIA.ordinal()] = 4;
+            } catch (NoSuchFieldError nosuchfielderror3) {
+                ;
+            }
+
+            try {
+                BlockFlowerPot.SyntheticClass_1.b[BlockFlowers.EnumFlowerVarient.RED_TULIP.ordinal()] = 5;
+            } catch (NoSuchFieldError nosuchfielderror4) {
+                ;
+            }
+
+            try {
+                BlockFlowerPot.SyntheticClass_1.b[BlockFlowers.EnumFlowerVarient.ORANGE_TULIP.ordinal()] = 6;
+            } catch (NoSuchFieldError nosuchfielderror5) {
+                ;
+            }
+
+            try {
+                BlockFlowerPot.SyntheticClass_1.b[BlockFlowers.EnumFlowerVarient.WHITE_TULIP.ordinal()] = 7;
+            } catch (NoSuchFieldError nosuchfielderror6) {
+                ;
+            }
+
+            try {
+                BlockFlowerPot.SyntheticClass_1.b[BlockFlowers.EnumFlowerVarient.PINK_TULIP.ordinal()] = 8;
+            } catch (NoSuchFieldError nosuchfielderror7) {
+                ;
+            }
+
+            try {
+                BlockFlowerPot.SyntheticClass_1.b[BlockFlowers.EnumFlowerVarient.OXEYE_DAISY.ordinal()] = 9;
+            } catch (NoSuchFieldError nosuchfielderror8) {
+                ;
+            }
+
+            a = new int[BlockWood.EnumLogVariant.values().length];
+
+            try {
+                BlockFlowerPot.SyntheticClass_1.a[BlockWood.EnumLogVariant.OAK.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror9) {
+                ;
+            }
+
+            try {
+                BlockFlowerPot.SyntheticClass_1.a[BlockWood.EnumLogVariant.SPRUCE.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror10) {
+                ;
+            }
+
+            try {
+                BlockFlowerPot.SyntheticClass_1.a[BlockWood.EnumLogVariant.BIRCH.ordinal()] = 3;
+            } catch (NoSuchFieldError nosuchfielderror11) {
+                ;
+            }
+
+            try {
+                BlockFlowerPot.SyntheticClass_1.a[BlockWood.EnumLogVariant.JUNGLE.ordinal()] = 4;
+            } catch (NoSuchFieldError nosuchfielderror12) {
+                ;
+            }
+
+            try {
+                BlockFlowerPot.SyntheticClass_1.a[BlockWood.EnumLogVariant.ACACIA.ordinal()] = 5;
+            } catch (NoSuchFieldError nosuchfielderror13) {
+                ;
+            }
+
+            try {
+                BlockFlowerPot.SyntheticClass_1.a[BlockWood.EnumLogVariant.DARK_OAK.ordinal()] = 6;
+            } catch (NoSuchFieldError nosuchfielderror14) {
+                ;
+            }
+
+        }
+    }
+
+    public static enum EnumFlowerPotContents implements INamable {
+
+        EMPTY("empty"), POPPY("rose"), BLUE_ORCHID("blue_orchid"), ALLIUM("allium"), HOUSTONIA("houstonia"), RED_TULIP("red_tulip"), ORANGE_TULIP("orange_tulip"), WHITE_TULIP("white_tulip"), PINK_TULIP("pink_tulip"), OXEYE_DAISY("oxeye_daisy"), DANDELION("dandelion"), OAK_SAPLING("oak_sapling"), SPRUCE_SAPLING("spruce_sapling"), BIRCH_SAPLING("birch_sapling"), JUNGLE_SAPLING("jungle_sapling"), ACACIA_SAPLING("acacia_sapling"), DARK_OAK_SAPLING("dark_oak_sapling"), MUSHROOM_RED("mushroom_red"), MUSHROOM_BROWN("mushroom_brown"), DEAD_BUSH("dead_bush"), FERN("fern"), CACTUS("cactus");
+
+        private final String w;
+
+        private EnumFlowerPotContents(String s) {
+            this.w = s;
+        }
+
+        public String toString() {
+            return this.w;
+        }
+
+        public String getName() {
+            return this.w;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockHopper.java b/src/main/java/net/minecraft/server/BlockHopper.java
new file mode 100644
index 0000000..9f9b45d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockHopper.java
@@ -0,0 +1,161 @@
+package net.minecraft.server;
+
+import com.google.common.base.Predicate;
+import java.util.List;
+
+public class BlockHopper extends BlockContainer {
+
+    public static final BlockStateDirection FACING = BlockStateDirection.of("facing", new Predicate() {
+        public boolean a(EnumDirection enumdirection) {
+            return enumdirection != EnumDirection.UP;
+        }
+
+        public boolean apply(Object object) {
+            return this.a((EnumDirection) object);
+        }
+    });
+    public static final BlockStateBoolean ENABLED = BlockStateBoolean.of("enabled");
+
+    public BlockHopper() {
+        super(Material.ORE, MaterialMapColor.m);
+        this.j(this.blockStateList.getBlockData().set(BlockHopper.FACING, EnumDirection.DOWN).set(BlockHopper.ENABLED, Boolean.valueOf(true)));
+        this.a(CreativeModeTab.d);
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+    }
+
+    public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+    }
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, Entity entity) {
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.625F, 1.0F);
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        float f = 0.125F;
+
+        this.a(0.0F, 0.0F, 0.0F, f, 1.0F, 1.0F);
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, f);
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        this.a(1.0F - f, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        this.a(0.0F, 0.0F, 1.0F - f, 1.0F, 1.0F, 1.0F);
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+    }
+
+    public IBlockData getPlacedState(World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2, int i, EntityLiving entityliving) {
+        EnumDirection enumdirection1 = enumdirection.opposite();
+
+        if (enumdirection1 == EnumDirection.UP) {
+            enumdirection1 = EnumDirection.DOWN;
+        }
+
+        return this.getBlockData().set(BlockHopper.FACING, enumdirection1).set(BlockHopper.ENABLED, Boolean.valueOf(true));
+    }
+
+    public TileEntity a(World world, int i) {
+        return new TileEntityHopper();
+    }
+
+    public void postPlace(World world, BlockPosition blockposition, IBlockData iblockdata, EntityLiving entityliving, ItemStack itemstack) {
+        super.postPlace(world, blockposition, iblockdata, entityliving, itemstack);
+        if (itemstack.hasName()) {
+            TileEntity tileentity = world.getTileEntity(blockposition);
+
+            if (tileentity instanceof TileEntityHopper) {
+                ((TileEntityHopper) tileentity).a(itemstack.getName());
+            }
+        }
+
+    }
+
+    public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        this.e(world, blockposition, iblockdata);
+    }
+
+    public boolean interact(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman, EnumDirection enumdirection, float f, float f1, float f2) {
+        if (world.isClientSide) {
+            return true;
+        } else {
+            TileEntity tileentity = world.getTileEntity(blockposition);
+
+            if (tileentity instanceof TileEntityHopper) {
+                entityhuman.openContainer((TileEntityHopper) tileentity);
+                entityhuman.b(StatisticList.P);
+            }
+
+            return true;
+        }
+    }
+
+    public void doPhysics(World world, BlockPosition blockposition, IBlockData iblockdata, Block block) {
+        this.e(world, blockposition, iblockdata);
+    }
+
+    private void e(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        boolean flag = !world.isBlockIndirectlyPowered(blockposition);
+
+        if (flag != ((Boolean) iblockdata.get(BlockHopper.ENABLED)).booleanValue()) {
+            world.setTypeAndData(blockposition, iblockdata.set(BlockHopper.ENABLED, Boolean.valueOf(flag)), 4);
+        }
+
+    }
+
+    public void remove(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        TileEntity tileentity = world.getTileEntity(blockposition);
+
+        if (tileentity instanceof TileEntityHopper) {
+            InventoryUtils.dropInventory(world, blockposition, (TileEntityHopper) tileentity);
+            world.updateAdjacentComparators(blockposition, this);
+        }
+
+        super.remove(world, blockposition, iblockdata);
+    }
+
+    public int b() {
+        return 3;
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public static EnumDirection b(int i) {
+        return EnumDirection.fromType1(i & 7);
+    }
+
+    public static boolean f(int i) {
+        return (i & 8) != 8;
+    }
+
+    public boolean isComplexRedstone() {
+        return true;
+    }
+
+    public int l(World world, BlockPosition blockposition) {
+        return Container.a(world.getTileEntity(blockposition));
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        return this.getBlockData().set(BlockHopper.FACING, b(i)).set(BlockHopper.ENABLED, Boolean.valueOf(f(i)));
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        byte b0 = 0;
+        int i = b0 | ((EnumDirection) iblockdata.get(BlockHopper.FACING)).a();
+
+        if (!((Boolean) iblockdata.get(BlockHopper.ENABLED)).booleanValue()) {
+            i |= 8;
+        }
+
+        return i;
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockHopper.FACING, BlockHopper.ENABLED});
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockTNT.java b/src/main/java/net/minecraft/server/BlockTNT.java
new file mode 100644
index 0000000..de2d648
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockTNT.java
@@ -0,0 +1,102 @@
+package net.minecraft.server;
+
+public class BlockTNT extends Block {
+
+    public static final BlockStateBoolean EXPLODE = BlockStateBoolean.of("explode");
+
+    public BlockTNT() {
+        super(Material.TNT);
+        this.j(this.blockStateList.getBlockData().set(BlockTNT.EXPLODE, Boolean.valueOf(false)));
+        this.a(CreativeModeTab.d);
+    }
+
+    public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        super.onPlace(world, blockposition, iblockdata);
+        if (world.isBlockIndirectlyPowered(blockposition)) {
+            this.postBreak(world, blockposition, iblockdata.set(BlockTNT.EXPLODE, Boolean.valueOf(true)));
+            world.setAir(blockposition);
+        }
+
+    }
+
+    public void doPhysics(World world, BlockPosition blockposition, IBlockData iblockdata, Block block) {
+        if (world.isBlockIndirectlyPowered(blockposition)) {
+            this.postBreak(world, blockposition, iblockdata.set(BlockTNT.EXPLODE, Boolean.valueOf(true)));
+            world.setAir(blockposition);
+        }
+
+    }
+
+    public void wasExploded(World world, BlockPosition blockposition, Explosion explosion) {
+        if (!world.isClientSide) {
+            EntityTNTPrimed entitytntprimed = new EntityTNTPrimed(world, (double) ((float) blockposition.getX() + 0.5F), (double) blockposition.getY(), (double) ((float) blockposition.getZ() + 0.5F), explosion.getSource());
+
+            entitytntprimed.fuseTicks = world.random.nextInt(entitytntprimed.fuseTicks / 4) + entitytntprimed.fuseTicks / 8;
+            world.addEntity(entitytntprimed);
+        }
+    }
+
+    public void postBreak(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        this.a(world, blockposition, iblockdata, (EntityLiving) null);
+    }
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, EntityLiving entityliving) {
+        if (!world.isClientSide) {
+            if (((Boolean) iblockdata.get(BlockTNT.EXPLODE)).booleanValue()) {
+                EntityTNTPrimed entitytntprimed = new EntityTNTPrimed(world, (double) ((float) blockposition.getX() + 0.5F), (double) blockposition.getY(), (double) ((float) blockposition.getZ() + 0.5F), entityliving);
+
+                world.addEntity(entitytntprimed);
+                world.makeSound(entitytntprimed, "game.tnt.primed", 1.0F, 1.0F);
+            }
+
+        }
+    }
+
+    public boolean interact(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman, EnumDirection enumdirection, float f, float f1, float f2) {
+        if (entityhuman.bZ() != null) {
+            Item item = entityhuman.bZ().getItem();
+
+            if (item == Items.FLINT_AND_STEEL || item == Items.FIRE_CHARGE) {
+                this.a(world, blockposition, iblockdata.set(BlockTNT.EXPLODE, Boolean.valueOf(true)), (EntityLiving) entityhuman);
+                world.setAir(blockposition);
+                if (item == Items.FLINT_AND_STEEL) {
+                    entityhuman.bZ().damage(1, entityhuman);
+                } else if (!entityhuman.abilities.canInstantlyBuild) {
+                    --entityhuman.bZ().count;
+                }
+
+                return true;
+            }
+        }
+
+        return super.interact(world, blockposition, iblockdata, entityhuman, enumdirection, f, f1, f2);
+    }
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, Entity entity) {
+        if (!world.isClientSide && entity instanceof EntityArrow) {
+            EntityArrow entityarrow = (EntityArrow) entity;
+
+            if (entityarrow.isBurning()) {
+                this.a(world, blockposition, world.getType(blockposition).set(BlockTNT.EXPLODE, Boolean.valueOf(true)), entityarrow.shooter instanceof EntityLiving ? (EntityLiving) entityarrow.shooter : null);
+                world.setAir(blockposition);
+            }
+        }
+
+    }
+
+    public boolean a(Explosion explosion) {
+        return false;
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        return this.getBlockData().set(BlockTNT.EXPLODE, Boolean.valueOf((i & 1) > 0));
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        return ((Boolean) iblockdata.get(BlockTNT.EXPLODE)).booleanValue() ? 1 : 0;
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockTNT.EXPLODE});
+    }
+}
diff --git a/src/main/java/net/minecraft/server/CommandDispatcher.java b/src/main/java/net/minecraft/server/CommandDispatcher.java
new file mode 100644
index 0000000..81289b7
--- /dev/null
+++ b/src/main/java/net/minecraft/server/CommandDispatcher.java
@@ -0,0 +1,118 @@
+package net.minecraft.server;
+
+import java.util.Iterator;
+
+public class CommandDispatcher extends CommandHandler implements ICommandDispatcher {
+
+    public CommandDispatcher() {
+        this.a((ICommand) (new CommandTime()));
+        this.a((ICommand) (new CommandGamemode()));
+        this.a((ICommand) (new CommandDifficulty()));
+        this.a((ICommand) (new CommandGamemodeDefault()));
+        this.a((ICommand) (new CommandKill()));
+        this.a((ICommand) (new CommandToggleDownfall()));
+        this.a((ICommand) (new CommandWeather()));
+        this.a((ICommand) (new CommandXp()));
+        this.a((ICommand) (new CommandTp()));
+        this.a((ICommand) (new CommandGive()));
+        this.a((ICommand) (new CommandReplaceItem()));
+        this.a((ICommand) (new CommandStats()));
+        this.a((ICommand) (new CommandEffect()));
+        this.a((ICommand) (new CommandEnchant()));
+        this.a((ICommand) (new CommandParticle()));
+        this.a((ICommand) (new CommandMe()));
+        this.a((ICommand) (new CommandSeed()));
+        this.a((ICommand) (new CommandHelp()));
+        this.a((ICommand) (new CommandDebug()));
+        this.a((ICommand) (new CommandTell()));
+        this.a((ICommand) (new CommandSay()));
+        this.a((ICommand) (new CommandSpawnpoint()));
+        this.a((ICommand) (new CommandSetWorldSpawn()));
+        this.a((ICommand) (new CommandGamerule()));
+        this.a((ICommand) (new CommandClear()));
+        this.a((ICommand) (new CommandTestFor()));
+        this.a((ICommand) (new CommandSpreadPlayers()));
+        this.a((ICommand) (new CommandPlaySound()));
+        this.a((ICommand) (new CommandScoreboard()));
+        this.a((ICommand) (new CommandExecute()));
+        this.a((ICommand) (new CommandTrigger()));
+        this.a((ICommand) (new CommandAchievement()));
+        this.a((ICommand) (new CommandSummon()));
+        this.a((ICommand) (new CommandSetBlock()));
+        this.a((ICommand) (new CommandFill()));
+        this.a((ICommand) (new CommandClone()));
+        this.a((ICommand) (new CommandTestForBlocks()));
+        this.a((ICommand) (new CommandBlockData()));
+        this.a((ICommand) (new CommandTestForBlock()));
+        this.a((ICommand) (new CommandTellRaw()));
+        this.a((ICommand) (new CommandWorldBorder()));
+        this.a((ICommand) (new CommandTitle()));
+        this.a((ICommand) (new CommandEntityData()));
+        if (MinecraftServer.getServer().ae()) {
+            this.a((ICommand) (new CommandOp()));
+            this.a((ICommand) (new CommandDeop()));
+            this.a((ICommand) (new CommandStop()));
+            this.a((ICommand) (new CommandSaveAll()));
+            this.a((ICommand) (new CommandSaveOff()));
+            this.a((ICommand) (new CommandSaveOn()));
+            this.a((ICommand) (new CommandBanIp()));
+            this.a((ICommand) (new CommandPardonIP()));
+            this.a((ICommand) (new CommandBan()));
+            this.a((ICommand) (new CommandBanList()));
+            this.a((ICommand) (new CommandPardon()));
+            this.a((ICommand) (new CommandKick()));
+            this.a((ICommand) (new CommandList()));
+            this.a((ICommand) (new CommandWhitelist()));
+            this.a((ICommand) (new CommandIdleTimeout()));
+        } else {
+            this.a((ICommand) (new CommandPublish()));
+        }
+
+        CommandAbstract.a((ICommandDispatcher) this);
+    }
+
+    public void a(ICommandListener icommandlistener, ICommand icommand, int i, String s, Object... aobject) {
+        boolean flag = true;
+        MinecraftServer minecraftserver = MinecraftServer.getServer();
+
+        if (!icommandlistener.getSendCommandFeedback()) {
+            flag = false;
+        }
+
+        ChatMessage chatmessage = new ChatMessage("chat.type.admin", new Object[] { icommandlistener.getName(), new ChatMessage(s, aobject)});
+
+        chatmessage.getChatModifier().setColor(EnumChatFormat.GRAY);
+        chatmessage.getChatModifier().setItalic(Boolean.valueOf(true));
+        if (flag) {
+            Iterator iterator = minecraftserver.getPlayerList().v().iterator();
+
+            while (iterator.hasNext()) {
+                EntityHuman entityhuman = (EntityHuman) iterator.next();
+
+                if (entityhuman != icommandlistener && minecraftserver.getPlayerList().isOp(entityhuman.getProfile()) && icommand.canUse(icommandlistener)) {
+                    boolean flag1 = icommandlistener instanceof MinecraftServer && MinecraftServer.getServer().r();
+                    boolean flag2 = icommandlistener instanceof RemoteControlCommandListener && MinecraftServer.getServer().q();
+
+                    if (flag1 || flag2 || !(icommandlistener instanceof RemoteControlCommandListener) && !(icommandlistener instanceof MinecraftServer)) {
+                        entityhuman.sendMessage(chatmessage);
+                    }
+                }
+            }
+        }
+
+        if (icommandlistener != minecraftserver && minecraftserver.worldServer[0].getGameRules().getBoolean("logAdminCommands")) {
+            minecraftserver.sendMessage(chatmessage);
+        }
+
+        boolean flag3 = minecraftserver.worldServer[0].getGameRules().getBoolean("sendCommandFeedback");
+
+        if (icommandlistener instanceof CommandBlockListenerAbstract) {
+            flag3 = ((CommandBlockListenerAbstract) icommandlistener).m();
+        }
+
+        if ((i & 1) != 1 && flag3 || icommandlistener instanceof MinecraftServer) {
+            icommandlistener.sendMessage(new ChatMessage(s, aobject));
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/server/DataWatcher.java b/src/main/java/net/minecraft/server/DataWatcher.java
new file mode 100644
index 0000000..2bf9196
--- /dev/null
+++ b/src/main/java/net/minecraft/server/DataWatcher.java
@@ -0,0 +1,361 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import org.apache.commons.lang3.ObjectUtils;
+
+public class DataWatcher {
+
+    private final Entity a;
+    private boolean b = true;
+    private static final Map<Class<?>, Integer> c = Maps.newHashMap();
+    private final Map<Integer, DataWatcher.WatchableObject> d = Maps.newHashMap();
+    private boolean e;
+    private ReadWriteLock f = new ReentrantReadWriteLock();
+
+    public DataWatcher(Entity entity) {
+        this.a = entity;
+    }
+
+    public <T> void a(int i, T t0) {
+        Integer integer = (Integer) DataWatcher.c.get(t0.getClass());
+
+        if (integer == null) {
+            throw new IllegalArgumentException("Unknown data type: " + t0.getClass());
+        } else if (i > 31) {
+            throw new IllegalArgumentException("Data value id is too big with " + i + "! (Max is " + 31 + ")");
+        } else if (this.d.containsKey(Integer.valueOf(i))) {
+            throw new IllegalArgumentException("Duplicate id value for " + i + "!");
+        } else {
+            DataWatcher.WatchableObject datawatcher_watchableobject = new DataWatcher.WatchableObject(integer.intValue(), i, t0);
+
+            this.f.writeLock().lock();
+            this.d.put(Integer.valueOf(i), datawatcher_watchableobject);
+            this.f.writeLock().unlock();
+            this.b = false;
+        }
+    }
+
+    public void add(int i, int j) {
+        DataWatcher.WatchableObject datawatcher_watchableobject = new DataWatcher.WatchableObject(j, i, (Object) null);
+
+        this.f.writeLock().lock();
+        this.d.put(Integer.valueOf(i), datawatcher_watchableobject);
+        this.f.writeLock().unlock();
+        this.b = false;
+    }
+
+    public byte getByte(int i) {
+        return ((Byte) this.j(i).b()).byteValue();
+    }
+
+    public short getShort(int i) {
+        return ((Short) this.j(i).b()).shortValue();
+    }
+
+    public int getInt(int i) {
+        return ((Integer) this.j(i).b()).intValue();
+    }
+
+    public float getFloat(int i) {
+        return ((Float) this.j(i).b()).floatValue();
+    }
+
+    public String getString(int i) {
+        return (String) this.j(i).b();
+    }
+
+    public ItemStack getItemStack(int i) {
+        return (ItemStack) this.j(i).b();
+    }
+
+    private DataWatcher.WatchableObject j(int i) {
+        this.f.readLock().lock();
+
+        DataWatcher.WatchableObject datawatcher_watchableobject;
+
+        try {
+            datawatcher_watchableobject = (DataWatcher.WatchableObject) this.d.get(Integer.valueOf(i));
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.a(throwable, "Getting synched entity data");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Synched entity data");
+
+            crashreportsystemdetails.a("Data ID", (Object) Integer.valueOf(i));
+            throw new ReportedException(crashreport);
+        }
+
+        this.f.readLock().unlock();
+        return datawatcher_watchableobject;
+    }
+
+    public Vector3f h(int i) {
+        return (Vector3f) this.j(i).b();
+    }
+
+    public <T> void watch(int i, T t0) {
+        DataWatcher.WatchableObject datawatcher_watchableobject = this.j(i);
+
+        if (ObjectUtils.notEqual(t0, datawatcher_watchableobject.b())) {
+            datawatcher_watchableobject.a(t0);
+            this.a.i(i);
+            datawatcher_watchableobject.a(true);
+            this.e = true;
+        }
+
+    }
+
+    public void update(int i) {
+        this.j(i).d = true;
+        this.e = true;
+    }
+
+    public boolean a() {
+        return this.e;
+    }
+
+    public static void a(List<DataWatcher.WatchableObject> list, PacketDataSerializer packetdataserializer) throws IOException {
+        if (list != null) {
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                DataWatcher.WatchableObject datawatcher_watchableobject = (DataWatcher.WatchableObject) iterator.next();
+
+                a(packetdataserializer, datawatcher_watchableobject);
+            }
+        }
+
+        packetdataserializer.writeByte(127);
+    }
+
+    public List<DataWatcher.WatchableObject> b() {
+        ArrayList arraylist = null;
+
+        if (this.e) {
+            this.f.readLock().lock();
+            Iterator iterator = this.d.values().iterator();
+
+            while (iterator.hasNext()) {
+                DataWatcher.WatchableObject datawatcher_watchableobject = (DataWatcher.WatchableObject) iterator.next();
+
+                if (datawatcher_watchableobject.d()) {
+                    datawatcher_watchableobject.a(false);
+                    if (arraylist == null) {
+                        arraylist = Lists.newArrayList();
+                    }
+
+                    arraylist.add(datawatcher_watchableobject);
+                }
+            }
+
+            this.f.readLock().unlock();
+        }
+
+        this.e = false;
+        return arraylist;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.f.readLock().lock();
+        Iterator iterator = this.d.values().iterator();
+
+        while (iterator.hasNext()) {
+            DataWatcher.WatchableObject datawatcher_watchableobject = (DataWatcher.WatchableObject) iterator.next();
+
+            a(packetdataserializer, datawatcher_watchableobject);
+        }
+
+        this.f.readLock().unlock();
+        packetdataserializer.writeByte(127);
+    }
+
+    public List<DataWatcher.WatchableObject> c() {
+        ArrayList arraylist = null;
+
+        this.f.readLock().lock();
+
+        DataWatcher.WatchableObject datawatcher_watchableobject;
+
+        for (Iterator iterator = this.d.values().iterator(); iterator.hasNext(); arraylist.add(datawatcher_watchableobject)) {
+            datawatcher_watchableobject = (DataWatcher.WatchableObject) iterator.next();
+            if (arraylist == null) {
+                arraylist = Lists.newArrayList();
+            }
+        }
+
+        this.f.readLock().unlock();
+        return arraylist;
+    }
+
+    private static void a(PacketDataSerializer packetdataserializer, DataWatcher.WatchableObject datawatcher_watchableobject) throws IOException {
+        int i = (datawatcher_watchableobject.c() << 5 | datawatcher_watchableobject.a() & 31) & 255;
+
+        packetdataserializer.writeByte(i);
+        switch (datawatcher_watchableobject.c()) {
+        case 0:
+            packetdataserializer.writeByte(((Byte) datawatcher_watchableobject.b()).byteValue());
+            break;
+
+        case 1:
+            packetdataserializer.writeShort(((Short) datawatcher_watchableobject.b()).shortValue());
+            break;
+
+        case 2:
+            packetdataserializer.writeInt(((Integer) datawatcher_watchableobject.b()).intValue());
+            break;
+
+        case 3:
+            packetdataserializer.writeFloat(((Float) datawatcher_watchableobject.b()).floatValue());
+            break;
+
+        case 4:
+            packetdataserializer.a((String) datawatcher_watchableobject.b());
+            break;
+
+        case 5:
+            ItemStack itemstack = (ItemStack) datawatcher_watchableobject.b();
+
+            packetdataserializer.a(itemstack);
+            break;
+
+        case 6:
+            BlockPosition blockposition = (BlockPosition) datawatcher_watchableobject.b();
+
+            packetdataserializer.writeInt(blockposition.getX());
+            packetdataserializer.writeInt(blockposition.getY());
+            packetdataserializer.writeInt(blockposition.getZ());
+            break;
+
+        case 7:
+            Vector3f vector3f = (Vector3f) datawatcher_watchableobject.b();
+
+            packetdataserializer.writeFloat(vector3f.getX());
+            packetdataserializer.writeFloat(vector3f.getY());
+            packetdataserializer.writeFloat(vector3f.getZ());
+        }
+
+    }
+
+    public static List<DataWatcher.WatchableObject> b(PacketDataSerializer packetdataserializer) throws IOException {
+        ArrayList arraylist = null;
+
+        for (byte b0 = packetdataserializer.readByte(); b0 != 127; b0 = packetdataserializer.readByte()) {
+            if (arraylist == null) {
+                arraylist = Lists.newArrayList();
+            }
+
+            int i = (b0 & 224) >> 5;
+            int j = b0 & 31;
+            DataWatcher.WatchableObject datawatcher_watchableobject = null;
+
+            switch (i) {
+            case 0:
+                datawatcher_watchableobject = new DataWatcher.WatchableObject(i, j, Byte.valueOf(packetdataserializer.readByte()));
+                break;
+
+            case 1:
+                datawatcher_watchableobject = new DataWatcher.WatchableObject(i, j, Short.valueOf(packetdataserializer.readShort()));
+                break;
+
+            case 2:
+                datawatcher_watchableobject = new DataWatcher.WatchableObject(i, j, Integer.valueOf(packetdataserializer.readInt()));
+                break;
+
+            case 3:
+                datawatcher_watchableobject = new DataWatcher.WatchableObject(i, j, Float.valueOf(packetdataserializer.readFloat()));
+                break;
+
+            case 4:
+                datawatcher_watchableobject = new DataWatcher.WatchableObject(i, j, packetdataserializer.c(32767));
+                break;
+
+            case 5:
+                datawatcher_watchableobject = new DataWatcher.WatchableObject(i, j, packetdataserializer.i());
+                break;
+
+            case 6:
+                int k = packetdataserializer.readInt();
+                int l = packetdataserializer.readInt();
+                int i1 = packetdataserializer.readInt();
+
+                datawatcher_watchableobject = new DataWatcher.WatchableObject(i, j, new BlockPosition(k, l, i1));
+                break;
+
+            case 7:
+                float f = packetdataserializer.readFloat();
+                float f1 = packetdataserializer.readFloat();
+                float f2 = packetdataserializer.readFloat();
+
+                datawatcher_watchableobject = new DataWatcher.WatchableObject(i, j, new Vector3f(f, f1, f2));
+            }
+
+            arraylist.add(datawatcher_watchableobject);
+        }
+
+        return arraylist;
+    }
+
+    public boolean d() {
+        return this.b;
+    }
+
+    public void e() {
+        this.e = false;
+    }
+
+    static {
+        DataWatcher.c.put(Byte.class, Integer.valueOf(0));
+        DataWatcher.c.put(Short.class, Integer.valueOf(1));
+        DataWatcher.c.put(Integer.class, Integer.valueOf(2));
+        DataWatcher.c.put(Float.class, Integer.valueOf(3));
+        DataWatcher.c.put(String.class, Integer.valueOf(4));
+        DataWatcher.c.put(ItemStack.class, Integer.valueOf(5));
+        DataWatcher.c.put(BlockPosition.class, Integer.valueOf(6));
+        DataWatcher.c.put(Vector3f.class, Integer.valueOf(7));
+    }
+
+    public static class WatchableObject {
+
+        private final int a;
+        private final int b;
+        private Object c;
+        private boolean d;
+
+        public WatchableObject(int i, int j, Object object) {
+            this.b = j;
+            this.c = object;
+            this.a = i;
+            this.d = true;
+        }
+
+        public int a() {
+            return this.b;
+        }
+
+        public void a(Object object) {
+            this.c = object;
+        }
+
+        public Object b() {
+            return this.c;
+        }
+
+        public int c() {
+            return this.a;
+        }
+
+        public boolean d() {
+            return this.d;
+        }
+
+        public void a(boolean flag) {
+            this.d = flag;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EnchantmentManager.java b/src/main/java/net/minecraft/server/EnchantmentManager.java
new file mode 100644
index 0000000..9865681
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EnchantmentManager.java
@@ -0,0 +1,450 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+
+public class EnchantmentManager {
+
+    private static final Random a = new Random();
+    private static final EnchantmentManager.EnchantmentModifierProtection b = new EnchantmentManager.EnchantmentModifierProtection((EnchantmentManager.SyntheticClass_1) null);
+    private static final EnchantmentManager.EnchantmentModifierDamage c = new EnchantmentManager.EnchantmentModifierDamage((EnchantmentManager.SyntheticClass_1) null);
+    private static final EnchantmentManager.EnchantmentModifierThorns d = new EnchantmentManager.EnchantmentModifierThorns((EnchantmentManager.SyntheticClass_1) null);
+    private static final EnchantmentManager.EnchantmentModifierArthropods e = new EnchantmentManager.EnchantmentModifierArthropods((EnchantmentManager.SyntheticClass_1) null);
+
+    public static int getEnchantmentLevel(int i, ItemStack itemstack) {
+        if (itemstack == null) {
+            return 0;
+        } else {
+            NBTTagList nbttaglist = itemstack.getEnchantments();
+
+            if (nbttaglist == null) {
+                return 0;
+            } else {
+                for (int j = 0; j < nbttaglist.size(); ++j) {
+                    short short0 = nbttaglist.get(j).getShort("id");
+                    short short1 = nbttaglist.get(j).getShort("lvl");
+
+                    if (short0 == i) {
+                        return short1;
+                    }
+                }
+
+                return 0;
+            }
+        }
+    }
+
+    public static Map<Integer, Integer> a(ItemStack itemstack) {
+        LinkedHashMap linkedhashmap = Maps.newLinkedHashMap();
+        NBTTagList nbttaglist = itemstack.getItem() == Items.ENCHANTED_BOOK ? Items.ENCHANTED_BOOK.h(itemstack) : itemstack.getEnchantments();
+
+        if (nbttaglist != null) {
+            for (int i = 0; i < nbttaglist.size(); ++i) {
+                short short0 = nbttaglist.get(i).getShort("id");
+                short short1 = nbttaglist.get(i).getShort("lvl");
+
+                linkedhashmap.put(Integer.valueOf(short0), Integer.valueOf(short1));
+            }
+        }
+
+        return linkedhashmap;
+    }
+
+    public static void a(Map<Integer, Integer> map, ItemStack itemstack) {
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = map.keySet().iterator();
+
+        while (iterator.hasNext()) {
+            int i = ((Integer) iterator.next()).intValue();
+            Enchantment enchantment = Enchantment.getById(i);
+
+            if (enchantment != null) {
+                NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+                nbttagcompound.setShort("id", (short) i);
+                nbttagcompound.setShort("lvl", (short) ((Integer) map.get(Integer.valueOf(i))).intValue());
+                nbttaglist.add(nbttagcompound);
+                if (itemstack.getItem() == Items.ENCHANTED_BOOK) {
+                    Items.ENCHANTED_BOOK.a(itemstack, new WeightedRandomEnchant(enchantment, ((Integer) map.get(Integer.valueOf(i))).intValue()));
+                }
+            }
+        }
+
+        if (nbttaglist.size() > 0) {
+            if (itemstack.getItem() != Items.ENCHANTED_BOOK) {
+                itemstack.a("ench", (NBTBase) nbttaglist);
+            }
+        } else if (itemstack.hasTag()) {
+            itemstack.getTag().remove("ench");
+        }
+
+    }
+
+    public static int a(int i, ItemStack[] aitemstack) {
+        if (aitemstack == null) {
+            return 0;
+        } else {
+            int j = 0;
+            ItemStack[] aitemstack1 = aitemstack;
+            int k = aitemstack.length;
+
+            for (int l = 0; l < k; ++l) {
+                ItemStack itemstack = aitemstack1[l];
+                int i1 = getEnchantmentLevel(i, itemstack);
+
+                if (i1 > j) {
+                    j = i1;
+                }
+            }
+
+            return j;
+        }
+    }
+
+    private static void a(EnchantmentManager.EnchantmentModifier enchantmentmanager_enchantmentmodifier, ItemStack itemstack) {
+        if (itemstack != null) {
+            NBTTagList nbttaglist = itemstack.getEnchantments();
+
+            if (nbttaglist != null) {
+                for (int i = 0; i < nbttaglist.size(); ++i) {
+                    short short0 = nbttaglist.get(i).getShort("id");
+                    short short1 = nbttaglist.get(i).getShort("lvl");
+
+                    if (Enchantment.getById(short0) != null) {
+                        enchantmentmanager_enchantmentmodifier.a(Enchantment.getById(short0), short1);
+                    }
+                }
+
+            }
+        }
+    }
+
+    private static void a(EnchantmentManager.EnchantmentModifier enchantmentmanager_enchantmentmodifier, ItemStack[] aitemstack) {
+        ItemStack[] aitemstack1 = aitemstack;
+        int i = aitemstack.length;
+
+        for (int j = 0; j < i; ++j) {
+            ItemStack itemstack = aitemstack1[j];
+
+            a(enchantmentmanager_enchantmentmodifier, itemstack);
+        }
+
+    }
+
+    public static int a(ItemStack[] aitemstack, DamageSource damagesource) {
+        EnchantmentManager.b.a = 0;
+        EnchantmentManager.b.b = damagesource;
+        a((EnchantmentManager.EnchantmentModifier) EnchantmentManager.b, aitemstack);
+        if (EnchantmentManager.b.a > 25) {
+            EnchantmentManager.b.a = 25;
+        } else if (EnchantmentManager.b.a < 0) {
+            EnchantmentManager.b.a = 0;
+        }
+
+        return (EnchantmentManager.b.a + 1 >> 1) + EnchantmentManager.a.nextInt((EnchantmentManager.b.a >> 1) + 1);
+    }
+
+    public static float a(ItemStack itemstack, EnumMonsterType enummonstertype) {
+        EnchantmentManager.c.a = 0.0F;
+        EnchantmentManager.c.b = enummonstertype;
+        a((EnchantmentManager.EnchantmentModifier) EnchantmentManager.c, itemstack);
+        return EnchantmentManager.c.a;
+    }
+
+    public static void a(EntityLiving entityliving, Entity entity) {
+        EnchantmentManager.d.b = entity;
+        EnchantmentManager.d.a = entityliving;
+        if (entityliving != null) {
+            a((EnchantmentManager.EnchantmentModifier) EnchantmentManager.d, entityliving.getEquipment());
+        }
+
+        if (entity instanceof EntityHuman) {
+            a((EnchantmentManager.EnchantmentModifier) EnchantmentManager.d, entityliving.bA());
+        }
+
+    }
+
+    public static void b(EntityLiving entityliving, Entity entity) {
+        EnchantmentManager.e.a = entityliving;
+        EnchantmentManager.e.b = entity;
+        if (entityliving != null) {
+            a((EnchantmentManager.EnchantmentModifier) EnchantmentManager.e, entityliving.getEquipment());
+        }
+
+        if (entityliving instanceof EntityHuman) {
+            a((EnchantmentManager.EnchantmentModifier) EnchantmentManager.e, entityliving.bA());
+        }
+
+    }
+
+    public static int a(EntityLiving entityliving) {
+        return getEnchantmentLevel(Enchantment.KNOCKBACK.id, entityliving.bA());
+    }
+
+    public static int getFireAspectEnchantmentLevel(EntityLiving entityliving) {
+        return getEnchantmentLevel(Enchantment.FIRE_ASPECT.id, entityliving.bA());
+    }
+
+    public static int getOxygenEnchantmentLevel(Entity entity) {
+        return a(Enchantment.OXYGEN.id, entity.getEquipment());
+    }
+
+    public static int b(Entity entity) {
+        return a(Enchantment.DEPTH_STRIDER.id, entity.getEquipment());
+    }
+
+    public static int getDigSpeedEnchantmentLevel(EntityLiving entityliving) {
+        return getEnchantmentLevel(Enchantment.DIG_SPEED.id, entityliving.bA());
+    }
+
+    public static boolean hasSilkTouchEnchantment(EntityLiving entityliving) {
+        return getEnchantmentLevel(Enchantment.SILK_TOUCH.id, entityliving.bA()) > 0;
+    }
+
+    public static int getBonusBlockLootEnchantmentLevel(EntityLiving entityliving) {
+        return getEnchantmentLevel(Enchantment.LOOT_BONUS_BLOCKS.id, entityliving.bA());
+    }
+
+    public static int g(EntityLiving entityliving) {
+        return getEnchantmentLevel(Enchantment.LUCK.id, entityliving.bA());
+    }
+
+    public static int h(EntityLiving entityliving) {
+        return getEnchantmentLevel(Enchantment.LURE.id, entityliving.bA());
+    }
+
+    public static int getBonusMonsterLootEnchantmentLevel(EntityLiving entityliving) {
+        return getEnchantmentLevel(Enchantment.LOOT_BONUS_MOBS.id, entityliving.bA());
+    }
+
+    public static boolean j(EntityLiving entityliving) {
+        return a(Enchantment.WATER_WORKER.id, entityliving.getEquipment()) > 0;
+    }
+
+    public static ItemStack a(Enchantment enchantment, EntityLiving entityliving) {
+        ItemStack[] aitemstack = entityliving.getEquipment();
+        int i = aitemstack.length;
+
+        for (int j = 0; j < i; ++j) {
+            ItemStack itemstack = aitemstack[j];
+
+            if (itemstack != null && getEnchantmentLevel(enchantment.id, itemstack) > 0) {
+                return itemstack;
+            }
+        }
+
+        return null;
+    }
+
+    public static int a(Random random, int i, int j, ItemStack itemstack) {
+        Item item = itemstack.getItem();
+        int k = item.b();
+
+        if (k <= 0) {
+            return 0;
+        } else {
+            if (j > 15) {
+                j = 15;
+            }
+
+            int l = random.nextInt(8) + 1 + (j >> 1) + random.nextInt(j + 1);
+
+            return i == 0 ? Math.max(l / 3, 1) : (i == 1 ? l * 2 / 3 + 1 : Math.max(l, j * 2));
+        }
+    }
+
+    public static ItemStack a(Random random, ItemStack itemstack, int i) {
+        List list = b(random, itemstack, i);
+        boolean flag = itemstack.getItem() == Items.BOOK;
+
+        if (flag) {
+            itemstack.setItem(Items.ENCHANTED_BOOK);
+        }
+
+        if (list != null) {
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                WeightedRandomEnchant weightedrandomenchant = (WeightedRandomEnchant) iterator.next();
+
+                if (flag) {
+                    Items.ENCHANTED_BOOK.a(itemstack, weightedrandomenchant);
+                } else {
+                    itemstack.addEnchantment(weightedrandomenchant.enchantment, weightedrandomenchant.level);
+                }
+            }
+        }
+
+        return itemstack;
+    }
+
+    public static List<WeightedRandomEnchant> b(Random random, ItemStack itemstack, int i) {
+        Item item = itemstack.getItem();
+        int j = item.b();
+
+        if (j <= 0) {
+            return null;
+        } else {
+            j /= 2;
+            j = 1 + random.nextInt((j >> 1) + 1) + random.nextInt((j >> 1) + 1);
+            int k = j + i;
+            float f = (random.nextFloat() + random.nextFloat() - 1.0F) * 0.15F;
+            int l = (int) ((float) k * (1.0F + f) + 0.5F);
+
+            if (l < 1) {
+                l = 1;
+            }
+
+            ArrayList arraylist = null;
+            Map map = b(l, itemstack);
+
+            if (map != null && !map.isEmpty()) {
+                WeightedRandomEnchant weightedrandomenchant = (WeightedRandomEnchant) WeightedRandom.a(random, map.values());
+
+                if (weightedrandomenchant != null) {
+                    arraylist = Lists.newArrayList();
+                    arraylist.add(weightedrandomenchant);
+
+                    for (int i1 = l; random.nextInt(50) <= i1; i1 >>= 1) {
+                        Iterator iterator = map.keySet().iterator();
+
+                        while (iterator.hasNext()) {
+                            Integer integer = (Integer) iterator.next();
+                            boolean flag = true;
+                            Iterator iterator1 = arraylist.iterator();
+
+                            while (true) {
+                                if (iterator1.hasNext()) {
+                                    WeightedRandomEnchant weightedrandomenchant1 = (WeightedRandomEnchant) iterator1.next();
+
+                                    if (weightedrandomenchant1.enchantment.a(Enchantment.getById(integer.intValue()))) {
+                                        continue;
+                                    }
+
+                                    flag = false;
+                                }
+
+                                if (!flag) {
+                                    iterator.remove();
+                                }
+                                break;
+                            }
+                        }
+
+                        if (!map.isEmpty()) {
+                            WeightedRandomEnchant weightedrandomenchant2 = (WeightedRandomEnchant) WeightedRandom.a(random, map.values());
+
+                            arraylist.add(weightedrandomenchant2);
+                        }
+                    }
+                }
+            }
+
+            return arraylist;
+        }
+    }
+
+    public static Map<Integer, WeightedRandomEnchant> b(int i, ItemStack itemstack) {
+        Item item = itemstack.getItem();
+        HashMap hashmap = null;
+        boolean flag = itemstack.getItem() == Items.BOOK;
+        Enchantment[] aenchantment = Enchantment.b;
+        int j = aenchantment.length;
+
+        for (int k = 0; k < j; ++k) {
+            Enchantment enchantment = aenchantment[k];
+
+            if (enchantment != null && (enchantment.slot.canEnchant(item) || flag)) {
+                for (int l = enchantment.getStartLevel(); l <= enchantment.getMaxLevel(); ++l) {
+                    if (i >= enchantment.a(l) && i <= enchantment.b(l)) {
+                        if (hashmap == null) {
+                            hashmap = Maps.newHashMap();
+                        }
+
+                        hashmap.put(Integer.valueOf(enchantment.id), new WeightedRandomEnchant(enchantment, l));
+                    }
+                }
+            }
+        }
+
+        return hashmap;
+    }
+
+    static class SyntheticClass_1 {    }
+
+    static final class EnchantmentModifierArthropods implements EnchantmentManager.EnchantmentModifier {
+
+        public EntityLiving a;
+        public Entity b;
+
+        private EnchantmentModifierArthropods() {}
+
+        public void a(Enchantment enchantment, int i) {
+            enchantment.a(this.a, this.b, i);
+        }
+
+        EnchantmentModifierArthropods(EnchantmentManager.SyntheticClass_1 enchantmentmanager_syntheticclass_1) {
+            this();
+        }
+    }
+
+    static final class EnchantmentModifierThorns implements EnchantmentManager.EnchantmentModifier {
+
+        public EntityLiving a;
+        public Entity b;
+
+        private EnchantmentModifierThorns() {}
+
+        public void a(Enchantment enchantment, int i) {
+            enchantment.b(this.a, this.b, i);
+        }
+
+        EnchantmentModifierThorns(EnchantmentManager.SyntheticClass_1 enchantmentmanager_syntheticclass_1) {
+            this();
+        }
+    }
+
+    static final class EnchantmentModifierDamage implements EnchantmentManager.EnchantmentModifier {
+
+        public float a;
+        public EnumMonsterType b;
+
+        private EnchantmentModifierDamage() {}
+
+        public void a(Enchantment enchantment, int i) {
+            this.a += enchantment.a(i, this.b);
+        }
+
+        EnchantmentModifierDamage(EnchantmentManager.SyntheticClass_1 enchantmentmanager_syntheticclass_1) {
+            this();
+        }
+    }
+
+    static final class EnchantmentModifierProtection implements EnchantmentManager.EnchantmentModifier {
+
+        public int a;
+        public DamageSource b;
+
+        private EnchantmentModifierProtection() {}
+
+        public void a(Enchantment enchantment, int i) {
+            this.a += enchantment.a(i, this.b);
+        }
+
+        EnchantmentModifierProtection(EnchantmentManager.SyntheticClass_1 enchantmentmanager_syntheticclass_1) {
+            this();
+        }
+    }
+
+    interface EnchantmentModifier {
+
+        void a(Enchantment enchantment, int i);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/FileIOThread.java b/src/main/java/net/minecraft/server/FileIOThread.java
new file mode 100644
index 0000000..198b00f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/FileIOThread.java
@@ -0,0 +1,75 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.Collections;
+import java.util.List;
+
+public class FileIOThread implements Runnable {
+
+    private static final FileIOThread a = new FileIOThread();
+    private List<IAsyncChunkSaver> b = Collections.synchronizedList(Lists.<IAsyncChunkSaver>newArrayList());
+    private volatile long c;
+    private volatile long d;
+    private volatile boolean e;
+
+    private FileIOThread() {
+        Thread thread = new Thread(this, "File IO Thread");
+
+        thread.setPriority(1);
+        thread.start();
+    }
+
+    public static FileIOThread a() {
+        return FileIOThread.a;
+    }
+
+    public void run() {
+        while (true) {
+            this.c();
+        }
+    }
+
+    private void c() {
+        for (int i = 0; i < this.b.size(); ++i) {
+            IAsyncChunkSaver iasyncchunksaver = (IAsyncChunkSaver) this.b.get(i);
+            boolean flag = iasyncchunksaver.c();
+
+            if (!flag) {
+                this.b.remove(i--);
+                ++this.d;
+            }
+
+            try {
+                Thread.sleep(this.e ? 0L : 10L);
+            } catch (InterruptedException interruptedexception) {
+                interruptedexception.printStackTrace();
+            }
+        }
+
+        if (this.b.isEmpty()) {
+            try {
+                Thread.sleep(25L);
+            } catch (InterruptedException interruptedexception1) {
+                interruptedexception1.printStackTrace();
+            }
+        }
+
+    }
+
+    public void a(IAsyncChunkSaver iasyncchunksaver) {
+        if (!this.b.contains(iasyncchunksaver)) {
+            ++this.c;
+            this.b.add(iasyncchunksaver);
+        }
+    }
+
+    public void b() throws InterruptedException {
+        this.e = true;
+
+        while (this.c != this.d) {
+            Thread.sleep(10L);
+        }
+
+        this.e = false;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/GameProfileBanEntry.java b/src/main/java/net/minecraft/server/GameProfileBanEntry.java
new file mode 100644
index 0000000..27ce9d9
--- /dev/null
+++ b/src/main/java/net/minecraft/server/GameProfileBanEntry.java
@@ -0,0 +1,47 @@
+package net.minecraft.server;
+
+import com.google.gson.JsonObject;
+import com.mojang.authlib.GameProfile;
+import java.util.Date;
+import java.util.UUID;
+
+public class GameProfileBanEntry extends ExpirableListEntry<GameProfile> {
+
+    public GameProfileBanEntry(GameProfile gameprofile) {
+        this(gameprofile, (Date) null, (String) null, (Date) null, (String) null);
+    }
+
+    public GameProfileBanEntry(GameProfile gameprofile, Date date, String s, Date date1, String s1) {
+        super(gameprofile, date1, s, date1, s1);
+    }
+
+    public GameProfileBanEntry(JsonObject jsonobject) {
+        super(b(jsonobject), jsonobject);
+    }
+
+    protected void a(JsonObject jsonobject) {
+        if (this.getKey() != null) {
+            jsonobject.addProperty("uuid", ((GameProfile) this.getKey()).getId() == null ? "" : ((GameProfile) this.getKey()).getId().toString());
+            jsonobject.addProperty("name", ((GameProfile) this.getKey()).getName());
+            super.a(jsonobject);
+        }
+    }
+
+    private static GameProfile b(JsonObject jsonobject) {
+        if (jsonobject.has("uuid") && jsonobject.has("name")) {
+            String s = jsonobject.get("uuid").getAsString();
+
+            UUID uuid;
+
+            try {
+                uuid = UUID.fromString(s);
+            } catch (Throwable throwable) {
+                return null;
+            }
+
+            return new GameProfile(uuid, jsonobject.get("name").getAsString());
+        } else {
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/GenericAttributes.java b/src/main/java/net/minecraft/server/GenericAttributes.java
new file mode 100644
index 0000000..3ed721a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/GenericAttributes.java
@@ -0,0 +1,114 @@
+package net.minecraft.server;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.UUID;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class GenericAttributes {
+
+    private static final Logger f = LogManager.getLogger();
+    public static final IAttribute maxHealth = (new AttributeRanged((IAttribute) null, "generic.maxHealth", 20.0D, 0.0D, 1024.0D)).a("Max Health").a(true);
+    public static final IAttribute FOLLOW_RANGE = (new AttributeRanged((IAttribute) null, "generic.followRange", 32.0D, 0.0D, 2048.0D)).a("Follow Range");
+    public static final IAttribute c = (new AttributeRanged((IAttribute) null, "generic.knockbackResistance", 0.0D, 0.0D, 1.0D)).a("Knockback Resistance");
+    public static final IAttribute MOVEMENT_SPEED = (new AttributeRanged((IAttribute) null, "generic.movementSpeed", 0.699999988079071D, 0.0D, 1024.0D)).a("Movement Speed").a(true);
+    public static final IAttribute ATTACK_DAMAGE = new AttributeRanged((IAttribute) null, "generic.attackDamage", 2.0D, 0.0D, 2048.0D);
+
+    public static NBTTagList a(AttributeMapBase attributemapbase) {
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = attributemapbase.a().iterator();
+
+        while (iterator.hasNext()) {
+            AttributeInstance attributeinstance = (AttributeInstance) iterator.next();
+
+            nbttaglist.add(a(attributeinstance));
+        }
+
+        return nbttaglist;
+    }
+
+    private static NBTTagCompound a(AttributeInstance attributeinstance) {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+        IAttribute iattribute = attributeinstance.getAttribute();
+
+        nbttagcompound.setString("Name", iattribute.getName());
+        nbttagcompound.setDouble("Base", attributeinstance.b());
+        Collection collection = attributeinstance.c();
+
+        if (collection != null && !collection.isEmpty()) {
+            NBTTagList nbttaglist = new NBTTagList();
+            Iterator iterator = collection.iterator();
+
+            while (iterator.hasNext()) {
+                AttributeModifier attributemodifier = (AttributeModifier) iterator.next();
+
+                if (attributemodifier.e()) {
+                    nbttaglist.add(a(attributemodifier));
+                }
+            }
+
+            nbttagcompound.set("Modifiers", nbttaglist);
+        }
+
+        return nbttagcompound;
+    }
+
+    private static NBTTagCompound a(AttributeModifier attributemodifier) {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+        nbttagcompound.setString("Name", attributemodifier.b());
+        nbttagcompound.setDouble("Amount", attributemodifier.d());
+        nbttagcompound.setInt("Operation", attributemodifier.c());
+        nbttagcompound.setLong("UUIDMost", attributemodifier.a().getMostSignificantBits());
+        nbttagcompound.setLong("UUIDLeast", attributemodifier.a().getLeastSignificantBits());
+        return nbttagcompound;
+    }
+
+    public static void a(AttributeMapBase attributemapbase, NBTTagList nbttaglist) {
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound = nbttaglist.get(i);
+            AttributeInstance attributeinstance = attributemapbase.a(nbttagcompound.getString("Name"));
+
+            if (attributeinstance != null) {
+                a(attributeinstance, nbttagcompound);
+            } else {
+                GenericAttributes.f.warn("Ignoring unknown attribute \'" + nbttagcompound.getString("Name") + "\'");
+            }
+        }
+
+    }
+
+    private static void a(AttributeInstance attributeinstance, NBTTagCompound nbttagcompound) {
+        attributeinstance.setValue(nbttagcompound.getDouble("Base"));
+        if (nbttagcompound.hasKeyOfType("Modifiers", 9)) {
+            NBTTagList nbttaglist = nbttagcompound.getList("Modifiers", 10);
+
+            for (int i = 0; i < nbttaglist.size(); ++i) {
+                AttributeModifier attributemodifier = a(nbttaglist.get(i));
+
+                if (attributemodifier != null) {
+                    AttributeModifier attributemodifier1 = attributeinstance.a(attributemodifier.a());
+
+                    if (attributemodifier1 != null) {
+                        attributeinstance.c(attributemodifier1);
+                    }
+
+                    attributeinstance.b(attributemodifier);
+                }
+            }
+        }
+
+    }
+
+    public static AttributeModifier a(NBTTagCompound nbttagcompound) {
+        UUID uuid = new UUID(nbttagcompound.getLong("UUIDMost"), nbttagcompound.getLong("UUIDLeast"));
+
+        try {
+            return new AttributeModifier(uuid, nbttagcompound.getString("Name"), nbttagcompound.getDouble("Amount"), nbttagcompound.getInt("Operation"));
+        } catch (Exception exception) {
+            GenericAttributes.f.warn("Unable to create attribute: " + exception.getMessage());
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/IntCache.java b/src/main/java/net/minecraft/server/IntCache.java
new file mode 100644
index 0000000..8167fdd
--- /dev/null
+++ b/src/main/java/net/minecraft/server/IntCache.java
@@ -0,0 +1,63 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.List;
+
+public class IntCache {
+
+    private static int a = 256;
+    private static List<int[]> b = Lists.newArrayList();
+    private static List<int[]> c = Lists.newArrayList();
+    private static List<int[]> d = Lists.newArrayList();
+    private static List<int[]> e = Lists.newArrayList();
+
+    public static synchronized int[] a(int i) {
+        int[] aint;
+
+        if (i <= 256) {
+            if (IntCache.b.isEmpty()) {
+                aint = new int[256];
+                IntCache.c.add(aint);
+                return aint;
+            } else {
+                aint = (int[]) IntCache.b.remove(IntCache.b.size() - 1);
+                IntCache.c.add(aint);
+                return aint;
+            }
+        } else if (i > IntCache.a) {
+            IntCache.a = i;
+            IntCache.d.clear();
+            IntCache.e.clear();
+            aint = new int[IntCache.a];
+            IntCache.e.add(aint);
+            return aint;
+        } else if (IntCache.d.isEmpty()) {
+            aint = new int[IntCache.a];
+            IntCache.e.add(aint);
+            return aint;
+        } else {
+            aint = (int[]) IntCache.d.remove(IntCache.d.size() - 1);
+            IntCache.e.add(aint);
+            return aint;
+        }
+    }
+
+    public static synchronized void a() {
+        if (!IntCache.d.isEmpty()) {
+            IntCache.d.remove(IntCache.d.size() - 1);
+        }
+
+        if (!IntCache.b.isEmpty()) {
+            IntCache.b.remove(IntCache.b.size() - 1);
+        }
+
+        IntCache.d.addAll(IntCache.e);
+        IntCache.b.addAll(IntCache.c);
+        IntCache.e.clear();
+        IntCache.c.clear();
+    }
+
+    public static synchronized String b() {
+        return "cache: " + IntCache.d.size() + ", tcache: " + IntCache.b.size() + ", allocated: " + IntCache.e.size() + ", tallocated: " + IntCache.c.size();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemDoor.java b/src/main/java/net/minecraft/server/ItemDoor.java
new file mode 100644
index 0000000..eef43df
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemDoor.java
@@ -0,0 +1,56 @@
+package net.minecraft.server;
+
+public class ItemDoor extends Item {
+
+    private Block a;
+
+    public ItemDoor(Block block) {
+        this.a = block;
+        this.a(CreativeModeTab.d);
+    }
+
+    public boolean interactWith(ItemStack itemstack, EntityHuman entityhuman, World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2) {
+        if (enumdirection != EnumDirection.UP) {
+            return false;
+        } else {
+            IBlockData iblockdata = world.getType(blockposition);
+            Block block = iblockdata.getBlock();
+
+            if (!block.a(world, blockposition)) {
+                blockposition = blockposition.shift(enumdirection);
+            }
+
+            if (!entityhuman.a(blockposition, enumdirection, itemstack)) {
+                return false;
+            } else if (!this.a.canPlace(world, blockposition)) {
+                return false;
+            } else {
+                a(world, blockposition, EnumDirection.fromAngle((double) entityhuman.yaw), this.a);
+                --itemstack.count;
+                return true;
+            }
+        }
+    }
+
+    public static void a(World world, BlockPosition blockposition, EnumDirection enumdirection, Block block) {
+        BlockPosition blockposition1 = blockposition.shift(enumdirection.e());
+        BlockPosition blockposition2 = blockposition.shift(enumdirection.f());
+        int i = (world.getType(blockposition2).getBlock().isOccluding() ? 1 : 0) + (world.getType(blockposition2.up()).getBlock().isOccluding() ? 1 : 0);
+        int j = (world.getType(blockposition1).getBlock().isOccluding() ? 1 : 0) + (world.getType(blockposition1.up()).getBlock().isOccluding() ? 1 : 0);
+        boolean flag = world.getType(blockposition2).getBlock() == block || world.getType(blockposition2.up()).getBlock() == block;
+        boolean flag1 = world.getType(blockposition1).getBlock() == block || world.getType(blockposition1.up()).getBlock() == block;
+        boolean flag2 = false;
+
+        if (flag && !flag1 || j > i) {
+            flag2 = true;
+        }
+
+        BlockPosition blockposition3 = blockposition.up();
+        IBlockData iblockdata = block.getBlockData().set(BlockDoor.FACING, enumdirection).set(BlockDoor.HINGE, flag2 ? BlockDoor.EnumDoorHinge.RIGHT : BlockDoor.EnumDoorHinge.LEFT);
+
+        world.setTypeAndData(blockposition, iblockdata.set(BlockDoor.HALF, BlockDoor.EnumDoorHalf.LOWER), 2);
+        world.setTypeAndData(blockposition3, iblockdata.set(BlockDoor.HALF, BlockDoor.EnumDoorHalf.UPPER), 2);
+        world.applyPhysics(blockposition, block);
+        world.applyPhysics(blockposition3, block);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemSkull.java b/src/main/java/net/minecraft/server/ItemSkull.java
new file mode 100644
index 0000000..a46cfef
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemSkull.java
@@ -0,0 +1,124 @@
+package net.minecraft.server;
+
+import com.mojang.authlib.GameProfile;
+import java.util.UUID;
+
+public class ItemSkull extends Item {
+
+    private static final String[] a = new String[] { "skeleton", "wither", "zombie", "char", "creeper"};
+
+    public ItemSkull() {
+        this.a(CreativeModeTab.c);
+        this.setMaxDurability(0);
+        this.a(true);
+    }
+
+    public boolean interactWith(ItemStack itemstack, EntityHuman entityhuman, World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2) {
+        if (enumdirection == EnumDirection.DOWN) {
+            return false;
+        } else {
+            IBlockData iblockdata = world.getType(blockposition);
+            Block block = iblockdata.getBlock();
+            boolean flag = block.a(world, blockposition);
+
+            if (!flag) {
+                if (!world.getType(blockposition).getBlock().getMaterial().isBuildable()) {
+                    return false;
+                }
+
+                blockposition = blockposition.shift(enumdirection);
+            }
+
+            if (!entityhuman.a(blockposition, enumdirection, itemstack)) {
+                return false;
+            } else if (!Blocks.SKULL.canPlace(world, blockposition)) {
+                return false;
+            } else {
+                if (!world.isClientSide) {
+                    world.setTypeAndData(blockposition, Blocks.SKULL.getBlockData().set(BlockSkull.FACING, enumdirection), 3);
+                    int i = 0;
+
+                    if (enumdirection == EnumDirection.UP) {
+                        i = MathHelper.floor((double) (entityhuman.yaw * 16.0F / 360.0F) + 0.5D) & 15;
+                    }
+
+                    TileEntity tileentity = world.getTileEntity(blockposition);
+
+                    if (tileentity instanceof TileEntitySkull) {
+                        TileEntitySkull tileentityskull = (TileEntitySkull) tileentity;
+
+                        if (itemstack.getData() == 3) {
+                            GameProfile gameprofile = null;
+
+                            if (itemstack.hasTag()) {
+                                NBTTagCompound nbttagcompound = itemstack.getTag();
+
+                                if (nbttagcompound.hasKeyOfType("SkullOwner", 10)) {
+                                    gameprofile = GameProfileSerializer.deserialize(nbttagcompound.getCompound("SkullOwner"));
+                                } else if (nbttagcompound.hasKeyOfType("SkullOwner", 8) && nbttagcompound.getString("SkullOwner").length() > 0) {
+                                    gameprofile = new GameProfile((UUID) null, nbttagcompound.getString("SkullOwner"));
+                                }
+                            }
+
+                            tileentityskull.setGameProfile(gameprofile);
+                        } else {
+                            tileentityskull.setSkullType(itemstack.getData());
+                        }
+
+                        tileentityskull.setRotation(i);
+                        Blocks.SKULL.a(world, blockposition, tileentityskull);
+                    }
+
+                    --itemstack.count;
+                }
+
+                return true;
+            }
+        }
+    }
+
+    public int filterData(int i) {
+        return i;
+    }
+
+    public String e_(ItemStack itemstack) {
+        int i = itemstack.getData();
+
+        if (i < 0 || i >= ItemSkull.a.length) {
+            i = 0;
+        }
+
+        return super.getName() + "." + ItemSkull.a[i];
+    }
+
+    public String a(ItemStack itemstack) {
+        if (itemstack.getData() == 3 && itemstack.hasTag()) {
+            if (itemstack.getTag().hasKeyOfType("SkullOwner", 8)) {
+                return LocaleI18n.a("item.skull.player.name", new Object[] { itemstack.getTag().getString("SkullOwner")});
+            }
+
+            if (itemstack.getTag().hasKeyOfType("SkullOwner", 10)) {
+                NBTTagCompound nbttagcompound = itemstack.getTag().getCompound("SkullOwner");
+
+                if (nbttagcompound.hasKeyOfType("Name", 8)) {
+                    return LocaleI18n.a("item.skull.player.name", new Object[] { nbttagcompound.getString("Name")});
+                }
+            }
+        }
+
+        return super.a(itemstack);
+    }
+
+    public boolean a(NBTTagCompound nbttagcompound) {
+        super.a(nbttagcompound);
+        if (nbttagcompound.hasKeyOfType("SkullOwner", 8) && nbttagcompound.getString("SkullOwner").length() > 0) {
+            GameProfile gameprofile = new GameProfile((UUID) null, nbttagcompound.getString("SkullOwner"));
+
+            gameprofile = TileEntitySkull.b(gameprofile);
+            nbttagcompound.set("SkullOwner", GameProfileSerializer.serialize(new NBTTagCompound(), gameprofile));
+            return true;
+        } else {
+            return false;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTBase.java b/src/main/java/net/minecraft/server/NBTBase.java
new file mode 100644
index 0000000..8756b63
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTBase.java
@@ -0,0 +1,104 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public abstract class NBTBase {
+
+    public static final String[] a = new String[] { "END", "BYTE", "SHORT", "INT", "LONG", "FLOAT", "DOUBLE", "BYTE[]", "STRING", "LIST", "COMPOUND", "INT[]"};
+
+    abstract void write(DataOutput dataoutput) throws IOException;
+
+    abstract void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException;
+
+    public abstract String toString();
+
+    public abstract byte getTypeId();
+
+    protected NBTBase() {}
+
+    protected static NBTBase createTag(byte b0) {
+        switch (b0) {
+        case 0:
+            return new NBTTagEnd();
+
+        case 1:
+            return new NBTTagByte();
+
+        case 2:
+            return new NBTTagShort();
+
+        case 3:
+            return new NBTTagInt();
+
+        case 4:
+            return new NBTTagLong();
+
+        case 5:
+            return new NBTTagFloat();
+
+        case 6:
+            return new NBTTagDouble();
+
+        case 7:
+            return new NBTTagByteArray();
+
+        case 8:
+            return new NBTTagString();
+
+        case 9:
+            return new NBTTagList();
+
+        case 10:
+            return new NBTTagCompound();
+
+        case 11:
+            return new NBTTagIntArray();
+
+        default:
+            return null;
+        }
+    }
+
+    public abstract NBTBase clone();
+
+    public boolean isEmpty() {
+        return false;
+    }
+
+    public boolean equals(Object object) {
+        if (!(object instanceof NBTBase)) {
+            return false;
+        } else {
+            NBTBase nbtbase = (NBTBase) object;
+
+            return this.getTypeId() == nbtbase.getTypeId();
+        }
+    }
+
+    public int hashCode() {
+        return this.getTypeId();
+    }
+
+    protected String a_() {
+        return this.toString();
+    }
+
+    public abstract static class NBTNumber extends NBTBase {
+
+        protected NBTNumber() {}
+
+        public abstract long c();
+
+        public abstract int d();
+
+        public abstract short e();
+
+        public abstract byte f();
+
+        public abstract double g();
+
+        public abstract float h();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTCompressedStreamTools.java b/src/main/java/net/minecraft/server/NBTCompressedStreamTools.java
new file mode 100644
index 0000000..2a04b86
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTCompressedStreamTools.java
@@ -0,0 +1,90 @@
+package net.minecraft.server;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.DataInput;
+import java.io.DataInputStream;
+import java.io.DataOutput;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+
+public class NBTCompressedStreamTools {
+
+    public static NBTTagCompound a(InputStream inputstream) throws IOException {
+        DataInputStream datainputstream = new DataInputStream(new BufferedInputStream(new GZIPInputStream(inputstream)));
+
+        NBTTagCompound nbttagcompound;
+
+        try {
+            nbttagcompound = a((DataInput) datainputstream, NBTReadLimiter.a);
+        } finally {
+            datainputstream.close();
+        }
+
+        return nbttagcompound;
+    }
+
+    public static void a(NBTTagCompound nbttagcompound, OutputStream outputstream) throws IOException {
+        DataOutputStream dataoutputstream = new DataOutputStream(new BufferedOutputStream(new GZIPOutputStream(outputstream)));
+
+        try {
+            a(nbttagcompound, (DataOutput) dataoutputstream);
+        } finally {
+            dataoutputstream.close();
+        }
+
+    }
+
+    public static NBTTagCompound a(DataInputStream datainputstream) throws IOException {
+        return a((DataInput) datainputstream, NBTReadLimiter.a);
+    }
+
+    public static NBTTagCompound a(DataInput datainput, NBTReadLimiter nbtreadlimiter) throws IOException {
+        NBTBase nbtbase = a(datainput, 0, nbtreadlimiter);
+
+        if (nbtbase instanceof NBTTagCompound) {
+            return (NBTTagCompound) nbtbase;
+        } else {
+            throw new IOException("Root tag must be a named compound tag");
+        }
+    }
+
+    public static void a(NBTTagCompound nbttagcompound, DataOutput dataoutput) throws IOException {
+        a((NBTBase) nbttagcompound, dataoutput);
+    }
+
+    private static void a(NBTBase nbtbase, DataOutput dataoutput) throws IOException {
+        dataoutput.writeByte(nbtbase.getTypeId());
+        if (nbtbase.getTypeId() != 0) {
+            dataoutput.writeUTF("");
+            nbtbase.write(dataoutput);
+        }
+    }
+
+    private static NBTBase a(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+        byte b0 = datainput.readByte();
+
+        if (b0 == 0) {
+            return new NBTTagEnd();
+        } else {
+            datainput.readUTF();
+            NBTBase nbtbase = NBTBase.createTag(b0);
+
+            try {
+                nbtbase.load(datainput, i, nbtreadlimiter);
+                return nbtbase;
+            } catch (IOException ioexception) {
+                CrashReport crashreport = CrashReport.a(ioexception, "Loading NBT data");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("NBT Tag");
+
+                crashreportsystemdetails.a("Tag name", (Object) "[UNNAMED TAG]");
+                crashreportsystemdetails.a("Tag type", (Object) Byte.valueOf(b0));
+                throw new ReportedException(crashreport);
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTTagByteArray.java b/src/main/java/net/minecraft/server/NBTTagByteArray.java
new file mode 100644
index 0000000..c6b5f70
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTTagByteArray.java
@@ -0,0 +1,58 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.Arrays;
+
+public class NBTTagByteArray extends NBTBase {
+
+    private byte[] data;
+
+    NBTTagByteArray() {}
+
+    public NBTTagByteArray(byte[] abyte) {
+        this.data = abyte;
+    }
+
+    void write(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.data.length);
+        dataoutput.write(this.data);
+    }
+
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+        nbtreadlimiter.a(192L);
+        int j = datainput.readInt();
+
+        nbtreadlimiter.a((long) (8 * j));
+        this.data = new byte[j];
+        datainput.readFully(this.data);
+    }
+
+    public byte getTypeId() {
+        return (byte) 7;
+    }
+
+    public String toString() {
+        return "[" + this.data.length + " bytes]";
+    }
+
+    public NBTBase clone() {
+        byte[] abyte = new byte[this.data.length];
+
+        System.arraycopy(this.data, 0, abyte, 0, this.data.length);
+        return new NBTTagByteArray(abyte);
+    }
+
+    public boolean equals(Object object) {
+        return super.equals(object) ? Arrays.equals(this.data, ((NBTTagByteArray) object).data) : false;
+    }
+
+    public int hashCode() {
+        return super.hashCode() ^ Arrays.hashCode(this.data);
+    }
+
+    public byte[] c() {
+        return this.data;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTTagIntArray.java b/src/main/java/net/minecraft/server/NBTTagIntArray.java
new file mode 100644
index 0000000..5f17034
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTTagIntArray.java
@@ -0,0 +1,76 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.Arrays;
+
+public class NBTTagIntArray extends NBTBase {
+
+    private int[] data;
+
+    NBTTagIntArray() {}
+
+    public NBTTagIntArray(int[] aint) {
+        this.data = aint;
+    }
+
+    void write(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.data.length);
+
+        for (int i = 0; i < this.data.length; ++i) {
+            dataoutput.writeInt(this.data[i]);
+        }
+
+    }
+
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+        nbtreadlimiter.a(192L);
+        int j = datainput.readInt();
+
+        nbtreadlimiter.a((long) (32 * j));
+        this.data = new int[j];
+
+        for (int k = 0; k < j; ++k) {
+            this.data[k] = datainput.readInt();
+        }
+
+    }
+
+    public byte getTypeId() {
+        return (byte) 11;
+    }
+
+    public String toString() {
+        String s = "[";
+        int[] aint = this.data;
+        int i = aint.length;
+
+        for (int j = 0; j < i; ++j) {
+            int k = aint[j];
+
+            s = s + k + ",";
+        }
+
+        return s + "]";
+    }
+
+    public NBTBase clone() {
+        int[] aint = new int[this.data.length];
+
+        System.arraycopy(this.data, 0, aint, 0, this.data.length);
+        return new NBTTagIntArray(aint);
+    }
+
+    public boolean equals(Object object) {
+        return super.equals(object) ? Arrays.equals(this.data, ((NBTTagIntArray) object).data) : false;
+    }
+
+    public int hashCode() {
+        return super.hashCode() ^ Arrays.hashCode(this.data);
+    }
+
+    public int[] c() {
+        return this.data;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NextTickListEntry.java b/src/main/java/net/minecraft/server/NextTickListEntry.java
new file mode 100644
index 0000000..648d255
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NextTickListEntry.java
@@ -0,0 +1,56 @@
+package net.minecraft.server;
+
+public class NextTickListEntry implements Comparable<NextTickListEntry> {
+
+    private static long d;
+    private final Block e;
+    public final BlockPosition a;
+    public long b;
+    public int c;
+    private long f;
+
+    public NextTickListEntry(BlockPosition blockposition, Block block) {
+        this.f = (long) (NextTickListEntry.d++);
+        this.a = blockposition;
+        this.e = block;
+    }
+
+    public boolean equals(Object object) {
+        if (!(object instanceof NextTickListEntry)) {
+            return false;
+        } else {
+            NextTickListEntry nextticklistentry = (NextTickListEntry) object;
+
+            return this.a.equals(nextticklistentry.a) && Block.a(this.e, nextticklistentry.e);
+        }
+    }
+
+    public int hashCode() {
+        return this.a.hashCode();
+    }
+
+    public NextTickListEntry a(long i) {
+        this.b = i;
+        return this;
+    }
+
+    public void a(int i) {
+        this.c = i;
+    }
+
+    public int a(NextTickListEntry nextticklistentry) {
+        return this.b < nextticklistentry.b ? -1 : (this.b > nextticklistentry.b ? 1 : (this.c != nextticklistentry.c ? this.c - nextticklistentry.c : (this.f < nextticklistentry.f ? -1 : (this.f > nextticklistentry.f ? 1 : 0))));
+    }
+
+    public String toString() {
+        return Block.getId(this.e) + ": " + this.a + ", " + this.b + ", " + this.c + ", " + this.f;
+    }
+
+    public Block a() {
+        return this.e;
+    }
+
+    public int compareTo(NextTickListEntry object) {
+        return this.a((NextTickListEntry) object);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NibbleArray.java b/src/main/java/net/minecraft/server/NibbleArray.java
new file mode 100644
index 0000000..9306f97
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NibbleArray.java
@@ -0,0 +1,58 @@
+package net.minecraft.server;
+
+public class NibbleArray {
+
+    private final byte[] a;
+
+    public NibbleArray() {
+        this.a = new byte[2048];
+    }
+
+    public NibbleArray(byte[] abyte) {
+        this.a = abyte;
+        if (abyte.length != 2048) {
+            throw new IllegalArgumentException("ChunkNibbleArrays should be 2048 bytes not: " + abyte.length);
+        }
+    }
+
+    public int a(int i, int j, int k) {
+        return this.a(this.b(i, j, k));
+    }
+
+    public void a(int i, int j, int k, int l) {
+        this.a(this.b(i, j, k), l);
+    }
+
+    private int b(int i, int j, int k) {
+        return j << 8 | k << 4 | i;
+    }
+
+    public int a(int i) {
+        int j = this.c(i);
+
+        return this.b(i) ? this.a[j] & 15 : this.a[j] >> 4 & 15;
+    }
+
+    public void a(int i, int j) {
+        int k = this.c(i);
+
+        if (this.b(i)) {
+            this.a[k] = (byte) (this.a[k] & 240 | j & 15);
+        } else {
+            this.a[k] = (byte) (this.a[k] & 15 | (j & 15) << 4);
+        }
+
+    }
+
+    private boolean b(int i) {
+        return (i & 1) == 0;
+    }
+
+    private int c(int i) {
+        return i >> 1;
+    }
+
+    public byte[] a() {
+        return this.a;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/OldChunkLoader.java b/src/main/java/net/minecraft/server/OldChunkLoader.java
new file mode 100644
index 0000000..670d626
--- /dev/null
+++ b/src/main/java/net/minecraft/server/OldChunkLoader.java
@@ -0,0 +1,145 @@
+package net.minecraft.server;
+
+public class OldChunkLoader {
+
+    public static OldChunkLoader.OldChunk a(NBTTagCompound nbttagcompound) {
+        int i = nbttagcompound.getInt("xPos");
+        int j = nbttagcompound.getInt("zPos");
+        OldChunkLoader.OldChunk oldchunkloader_oldchunk = new OldChunkLoader.OldChunk(i, j);
+
+        oldchunkloader_oldchunk.g = nbttagcompound.getByteArray("Blocks");
+        oldchunkloader_oldchunk.f = new OldNibbleArray(nbttagcompound.getByteArray("Data"), 7);
+        oldchunkloader_oldchunk.e = new OldNibbleArray(nbttagcompound.getByteArray("SkyLight"), 7);
+        oldchunkloader_oldchunk.d = new OldNibbleArray(nbttagcompound.getByteArray("BlockLight"), 7);
+        oldchunkloader_oldchunk.c = nbttagcompound.getByteArray("HeightMap");
+        oldchunkloader_oldchunk.b = nbttagcompound.getBoolean("TerrainPopulated");
+        oldchunkloader_oldchunk.h = nbttagcompound.getList("Entities", 10);
+        oldchunkloader_oldchunk.i = nbttagcompound.getList("TileEntities", 10);
+        oldchunkloader_oldchunk.j = nbttagcompound.getList("TileTicks", 10);
+
+        try {
+            oldchunkloader_oldchunk.a = nbttagcompound.getLong("LastUpdate");
+        } catch (ClassCastException classcastexception) {
+            oldchunkloader_oldchunk.a = (long) nbttagcompound.getInt("LastUpdate");
+        }
+
+        return oldchunkloader_oldchunk;
+    }
+
+    public static void a(OldChunkLoader.OldChunk oldchunkloader_oldchunk, NBTTagCompound nbttagcompound, WorldChunkManager worldchunkmanager) {
+        nbttagcompound.setInt("xPos", oldchunkloader_oldchunk.k);
+        nbttagcompound.setInt("zPos", oldchunkloader_oldchunk.l);
+        nbttagcompound.setLong("LastUpdate", oldchunkloader_oldchunk.a);
+        int[] aint = new int[oldchunkloader_oldchunk.c.length];
+
+        for (int i = 0; i < oldchunkloader_oldchunk.c.length; ++i) {
+            aint[i] = oldchunkloader_oldchunk.c[i];
+        }
+
+        nbttagcompound.setIntArray("HeightMap", aint);
+        nbttagcompound.setBoolean("TerrainPopulated", oldchunkloader_oldchunk.b);
+        NBTTagList nbttaglist = new NBTTagList();
+
+        int j;
+        int k;
+
+        for (int l = 0; l < 8; ++l) {
+            boolean flag = true;
+
+            for (j = 0; j < 16 && flag; ++j) {
+                k = 0;
+
+                while (k < 16 && flag) {
+                    int i1 = 0;
+
+                    while (true) {
+                        if (i1 < 16) {
+                            int j1 = j << 11 | i1 << 7 | k + (l << 4);
+                            byte b0 = oldchunkloader_oldchunk.g[j1];
+
+                            if (b0 == 0) {
+                                ++i1;
+                                continue;
+                            }
+
+                            flag = false;
+                        }
+
+                        ++k;
+                        break;
+                    }
+                }
+            }
+
+            if (!flag) {
+                byte[] abyte = new byte[4096];
+                NibbleArray nibblearray = new NibbleArray();
+                NibbleArray nibblearray1 = new NibbleArray();
+                NibbleArray nibblearray2 = new NibbleArray();
+
+                for (int k1 = 0; k1 < 16; ++k1) {
+                    for (int l1 = 0; l1 < 16; ++l1) {
+                        for (int i2 = 0; i2 < 16; ++i2) {
+                            int j2 = k1 << 11 | i2 << 7 | l1 + (l << 4);
+                            byte b1 = oldchunkloader_oldchunk.g[j2];
+
+                            abyte[l1 << 8 | i2 << 4 | k1] = (byte) (b1 & 255);
+                            nibblearray.a(k1, l1, i2, oldchunkloader_oldchunk.f.a(k1, l1 + (l << 4), i2));
+                            nibblearray1.a(k1, l1, i2, oldchunkloader_oldchunk.e.a(k1, l1 + (l << 4), i2));
+                            nibblearray2.a(k1, l1, i2, oldchunkloader_oldchunk.d.a(k1, l1 + (l << 4), i2));
+                        }
+                    }
+                }
+
+                NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+                nbttagcompound1.setByte("Y", (byte) (l & 255));
+                nbttagcompound1.setByteArray("Blocks", abyte);
+                nbttagcompound1.setByteArray("Data", nibblearray.a());
+                nbttagcompound1.setByteArray("SkyLight", nibblearray1.a());
+                nbttagcompound1.setByteArray("BlockLight", nibblearray2.a());
+                nbttaglist.add(nbttagcompound1);
+            }
+        }
+
+        nbttagcompound.set("Sections", nbttaglist);
+        byte[] abyte1 = new byte[256];
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+
+        for (j = 0; j < 16; ++j) {
+            for (k = 0; k < 16; ++k) {
+                blockposition_mutableblockposition.c(oldchunkloader_oldchunk.k << 4 | j, 0, oldchunkloader_oldchunk.l << 4 | k);
+                abyte1[k << 4 | j] = (byte) (worldchunkmanager.getBiome(blockposition_mutableblockposition, BiomeBase.ad).id & 255);
+            }
+        }
+
+        nbttagcompound.setByteArray("Biomes", abyte1);
+        nbttagcompound.set("Entities", oldchunkloader_oldchunk.h);
+        nbttagcompound.set("TileEntities", oldchunkloader_oldchunk.i);
+        if (oldchunkloader_oldchunk.j != null) {
+            nbttagcompound.set("TileTicks", oldchunkloader_oldchunk.j);
+        }
+
+    }
+
+    public static class OldChunk {
+
+        public long a;
+        public boolean b;
+        public byte[] c;
+        public OldNibbleArray d;
+        public OldNibbleArray e;
+        public OldNibbleArray f;
+        public byte[] g;
+        public NBTTagList h;
+        public NBTTagList i;
+        public NBTTagList j;
+        public final int k;
+        public final int l;
+
+        public OldChunk(int i, int j) {
+            this.k = i;
+            this.l = j;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketHandshakingInSetProtocol.java b/src/main/java/net/minecraft/server/PacketHandshakingInSetProtocol.java
new file mode 100644
index 0000000..9c7b691
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketHandshakingInSetProtocol.java
@@ -0,0 +1,39 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+public class PacketHandshakingInSetProtocol implements Packet<PacketHandshakingInListener> {
+
+    private int a;
+    public String hostname;
+    public int port;
+    private EnumProtocol d;
+
+    public PacketHandshakingInSetProtocol() {}
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.e();
+        this.hostname = packetdataserializer.c(255);
+        this.port = packetdataserializer.readUnsignedShort();
+        this.d = EnumProtocol.a(packetdataserializer.e());
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.b(this.a);
+        packetdataserializer.a(this.hostname);
+        packetdataserializer.writeShort(this.port);
+        packetdataserializer.b(this.d.a());
+    }
+
+    public void a(PacketHandshakingInListener packethandshakinginlistener) {
+        packethandshakinginlistener.a(this);
+    }
+
+    public EnumProtocol a() {
+        return this.d;
+    }
+
+    public int b() {
+        return this.a;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayInArmAnimation.java b/src/main/java/net/minecraft/server/PacketPlayInArmAnimation.java
new file mode 100644
index 0000000..c611db1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayInArmAnimation.java
@@ -0,0 +1,16 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+public class PacketPlayInArmAnimation implements Packet<PacketListenerPlayIn> {
+
+    public PacketPlayInArmAnimation() {}
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {}
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {}
+
+    public void a(PacketListenerPlayIn packetlistenerplayin) {
+        packetlistenerplayin.a(this);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayInChat.java b/src/main/java/net/minecraft/server/PacketPlayInChat.java
new file mode 100644
index 0000000..0ab90f3
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayInChat.java
@@ -0,0 +1,34 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+public class PacketPlayInChat implements Packet<PacketListenerPlayIn> {
+
+    private String a;
+
+    public PacketPlayInChat() {}
+
+    public PacketPlayInChat(String s) {
+        if (s.length() > 100) {
+            s = s.substring(0, 100);
+        }
+
+        this.a = s;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.c(100);
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a(this.a);
+    }
+
+    public void a(PacketListenerPlayIn packetlistenerplayin) {
+        packetlistenerplayin.a(this);
+    }
+
+    public String a() {
+        return this.a;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
new file mode 100644
index 0000000..6e368f5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
@@ -0,0 +1,119 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+
+public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
+
+    private int a;
+    private int b;
+    private PacketPlayOutMapChunk.ChunkMap c;
+    private boolean d;
+
+    public PacketPlayOutMapChunk() {}
+
+    public PacketPlayOutMapChunk(Chunk chunk, boolean flag, int i) {
+        this.a = chunk.locX;
+        this.b = chunk.locZ;
+        this.d = flag;
+        this.c = a(chunk, flag, !chunk.getWorld().worldProvider.o(), i);
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.readInt();
+        this.b = packetdataserializer.readInt();
+        this.d = packetdataserializer.readBoolean();
+        this.c = new PacketPlayOutMapChunk.ChunkMap();
+        this.c.b = packetdataserializer.readShort();
+        this.c.a = packetdataserializer.a();
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.writeInt(this.a);
+        packetdataserializer.writeInt(this.b);
+        packetdataserializer.writeBoolean(this.d);
+        packetdataserializer.writeShort((short) (this.c.b & '\uffff'));
+        packetdataserializer.a(this.c.a);
+    }
+
+    public void a(PacketListenerPlayOut packetlistenerplayout) {
+        packetlistenerplayout.a(this);
+    }
+
+    protected static int a(int i, boolean flag, boolean flag1) {
+        int j = i * 2 * 16 * 16 * 16;
+        int k = i * 16 * 16 * 16 / 2;
+        int l = flag ? i * 16 * 16 * 16 / 2 : 0;
+        int i1 = flag1 ? 256 : 0;
+
+        return j + k + l + i1;
+    }
+
+    public static PacketPlayOutMapChunk.ChunkMap a(Chunk chunk, boolean flag, boolean flag1, int i) {
+        ChunkSection[] achunksection = chunk.getSections();
+        PacketPlayOutMapChunk.ChunkMap packetplayoutmapchunk_chunkmap = new PacketPlayOutMapChunk.ChunkMap();
+        ArrayList arraylist = Lists.newArrayList();
+
+        int j;
+
+        for (j = 0; j < achunksection.length; ++j) {
+            ChunkSection chunksection = achunksection[j];
+
+            if (chunksection != null && (!flag || !chunksection.a()) && (i & 1 << j) != 0) {
+                packetplayoutmapchunk_chunkmap.b |= 1 << j;
+                arraylist.add(chunksection);
+            }
+        }
+
+        packetplayoutmapchunk_chunkmap.a = new byte[a(Integer.bitCount(packetplayoutmapchunk_chunkmap.b), flag1, flag)];
+        j = 0;
+        Iterator iterator = arraylist.iterator();
+
+        ChunkSection chunksection1;
+
+        while (iterator.hasNext()) {
+            chunksection1 = (ChunkSection) iterator.next();
+            char[] achar = chunksection1.getIdArray();
+            char[] achar1 = achar;
+            int k = achar.length;
+
+            for (int l = 0; l < k; ++l) {
+                char c0 = achar1[l];
+
+                packetplayoutmapchunk_chunkmap.a[j++] = (byte) (c0 & 255);
+                packetplayoutmapchunk_chunkmap.a[j++] = (byte) (c0 >> 8 & 255);
+            }
+        }
+
+        for (iterator = arraylist.iterator(); iterator.hasNext(); j = a(chunksection1.getEmittedLightArray().a(), packetplayoutmapchunk_chunkmap.a, j)) {
+            chunksection1 = (ChunkSection) iterator.next();
+        }
+
+        if (flag1) {
+            for (iterator = arraylist.iterator(); iterator.hasNext(); j = a(chunksection1.getSkyLightArray().a(), packetplayoutmapchunk_chunkmap.a, j)) {
+                chunksection1 = (ChunkSection) iterator.next();
+            }
+        }
+
+        if (flag) {
+            a(chunk.getBiomeIndex(), packetplayoutmapchunk_chunkmap.a, j);
+        }
+
+        return packetplayoutmapchunk_chunkmap;
+    }
+
+    private static int a(byte[] abyte, byte[] abyte1, int i) {
+        System.arraycopy(abyte, 0, abyte1, i, abyte.length);
+        return i + abyte.length;
+    }
+
+    public static class ChunkMap {
+
+        public byte[] a;
+        public int b;
+
+        public ChunkMap() {}
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java
new file mode 100644
index 0000000..63b90f7
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java
@@ -0,0 +1,79 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+import java.util.List;
+
+public class PacketPlayOutMapChunkBulk implements Packet<PacketListenerPlayOut> {
+
+    private int[] a;
+    private int[] b;
+    private PacketPlayOutMapChunk.ChunkMap[] c;
+    private boolean d;
+
+    public PacketPlayOutMapChunkBulk() {}
+
+    public PacketPlayOutMapChunkBulk(List<Chunk> list) {
+        int i = list.size();
+
+        this.a = new int[i];
+        this.b = new int[i];
+        this.c = new PacketPlayOutMapChunk.ChunkMap[i];
+        this.d = !((Chunk) list.get(0)).getWorld().worldProvider.o();
+
+        for (int j = 0; j < i; ++j) {
+            Chunk chunk = (Chunk) list.get(j);
+            PacketPlayOutMapChunk.ChunkMap packetplayoutmapchunk_chunkmap = PacketPlayOutMapChunk.a(chunk, true, this.d, '\uffff');
+
+            this.a[j] = chunk.locX;
+            this.b[j] = chunk.locZ;
+            this.c[j] = packetplayoutmapchunk_chunkmap;
+        }
+
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.d = packetdataserializer.readBoolean();
+        int i = packetdataserializer.e();
+
+        this.a = new int[i];
+        this.b = new int[i];
+        this.c = new PacketPlayOutMapChunk.ChunkMap[i];
+
+        int j;
+
+        for (j = 0; j < i; ++j) {
+            this.a[j] = packetdataserializer.readInt();
+            this.b[j] = packetdataserializer.readInt();
+            this.c[j] = new PacketPlayOutMapChunk.ChunkMap();
+            this.c[j].b = packetdataserializer.readShort() & '\uffff';
+            this.c[j].a = new byte[PacketPlayOutMapChunk.a(Integer.bitCount(this.c[j].b), this.d, true)];
+        }
+
+        for (j = 0; j < i; ++j) {
+            packetdataserializer.readBytes(this.c[j].a);
+        }
+
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.writeBoolean(this.d);
+        packetdataserializer.b(this.c.length);
+
+        int i;
+
+        for (i = 0; i < this.a.length; ++i) {
+            packetdataserializer.writeInt(this.a[i]);
+            packetdataserializer.writeInt(this.b[i]);
+            packetdataserializer.writeShort((short) (this.c[i].b & '\uffff'));
+        }
+
+        for (i = 0; i < this.a.length; ++i) {
+            packetdataserializer.writeBytes(this.c[i].a);
+        }
+
+    }
+
+    public void a(PacketListenerPlayOut packetlistenerplayout) {
+        packetlistenerplayout.a(this);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutOpenWindow.java b/src/main/java/net/minecraft/server/PacketPlayOutOpenWindow.java
new file mode 100644
index 0000000..c168194
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutOpenWindow.java
@@ -0,0 +1,56 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+public class PacketPlayOutOpenWindow implements Packet<PacketListenerPlayOut> {
+
+    private int a;
+    private String b;
+    private IChatBaseComponent c;
+    private int d;
+    private int e;
+
+    public PacketPlayOutOpenWindow() {}
+
+    public PacketPlayOutOpenWindow(int i, String s, IChatBaseComponent ichatbasecomponent) {
+        this(i, s, ichatbasecomponent, 0);
+    }
+
+    public PacketPlayOutOpenWindow(int i, String s, IChatBaseComponent ichatbasecomponent, int j) {
+        this.a = i;
+        this.b = s;
+        this.c = ichatbasecomponent;
+        this.d = j;
+    }
+
+    public PacketPlayOutOpenWindow(int i, String s, IChatBaseComponent ichatbasecomponent, int j, int k) {
+        this(i, s, ichatbasecomponent, j);
+        this.e = k;
+    }
+
+    public void a(PacketListenerPlayOut packetlistenerplayout) {
+        packetlistenerplayout.a(this);
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.readUnsignedByte();
+        this.b = packetdataserializer.c(32);
+        this.c = packetdataserializer.d();
+        this.d = packetdataserializer.readUnsignedByte();
+        if (this.b.equals("EntityHorse")) {
+            this.e = packetdataserializer.readInt();
+        }
+
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.writeByte(this.a);
+        packetdataserializer.a(this.b);
+        packetdataserializer.a(this.c);
+        packetdataserializer.writeByte(this.d);
+        if (this.b.equals("EntityHorse")) {
+            packetdataserializer.writeInt(this.e);
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalSwell.java b/src/main/java/net/minecraft/server/PathfinderGoalSwell.java
new file mode 100644
index 0000000..c8eebf8
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalSwell.java
@@ -0,0 +1,39 @@
+package net.minecraft.server;
+
+public class PathfinderGoalSwell extends PathfinderGoal {
+
+    EntityCreeper a;
+    EntityLiving b;
+
+    public PathfinderGoalSwell(EntityCreeper entitycreeper) {
+        this.a = entitycreeper;
+        this.a(1);
+    }
+
+    public boolean a() {
+        EntityLiving entityliving = this.a.getGoalTarget();
+
+        return this.a.cm() > 0 || entityliving != null && this.a.h(entityliving) < 9.0D;
+    }
+
+    public void c() {
+        this.a.getNavigation().n();
+        this.b = this.a.getGoalTarget();
+    }
+
+    public void d() {
+        this.b = null;
+    }
+
+    public void e() {
+        if (this.b == null) {
+            this.a.a(-1);
+        } else if (this.a.h(this.b) > 49.0D) {
+            this.a.a(-1);
+        } else if (!this.a.getEntitySenses().a(this.b)) {
+            this.a.a(-1);
+        } else {
+            this.a.a(1);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PersistentCollection.java b/src/main/java/net/minecraft/server/PersistentCollection.java
new file mode 100644
index 0000000..4b8d548
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PersistentCollection.java
@@ -0,0 +1,184 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import java.io.DataInputStream;
+import java.io.DataOutput;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+public class PersistentCollection {
+
+    private IDataManager b;
+    protected Map<String, PersistentBase> a = Maps.newHashMap();
+    private List<PersistentBase> c = Lists.newArrayList();
+    private Map<String, Short> d = Maps.newHashMap();
+
+    public PersistentCollection(IDataManager idatamanager) {
+        this.b = idatamanager;
+        this.b();
+    }
+
+    public PersistentBase get(Class<? extends PersistentBase> oclass, String s) {
+        PersistentBase persistentbase = (PersistentBase) this.a.get(s);
+
+        if (persistentbase != null) {
+            return persistentbase;
+        } else {
+            if (this.b != null) {
+                try {
+                    File file = this.b.getDataFile(s);
+
+                    if (file != null && file.exists()) {
+                        try {
+                            persistentbase = (PersistentBase) oclass.getConstructor(new Class[] { String.class}).newInstance(new Object[] { s});
+                        } catch (Exception exception) {
+                            throw new RuntimeException("Failed to instantiate " + oclass.toString(), exception);
+                        }
+
+                        FileInputStream fileinputstream = new FileInputStream(file);
+                        NBTTagCompound nbttagcompound = NBTCompressedStreamTools.a((InputStream) fileinputstream);
+
+                        fileinputstream.close();
+                        persistentbase.a(nbttagcompound.getCompound("data"));
+                    }
+                } catch (Exception exception1) {
+                    exception1.printStackTrace();
+                }
+            }
+
+            if (persistentbase != null) {
+                this.a.put(s, persistentbase);
+                this.c.add(persistentbase);
+            }
+
+            return persistentbase;
+        }
+    }
+
+    public void a(String s, PersistentBase persistentbase) {
+        if (this.a.containsKey(s)) {
+            this.c.remove(this.a.remove(s));
+        }
+
+        this.a.put(s, persistentbase);
+        this.c.add(persistentbase);
+    }
+
+    public void a() {
+        for (int i = 0; i < this.c.size(); ++i) {
+            PersistentBase persistentbase = (PersistentBase) this.c.get(i);
+
+            if (persistentbase.d()) {
+                this.a(persistentbase);
+                persistentbase.a(false);
+            }
+        }
+
+    }
+
+    private void a(PersistentBase persistentbase) {
+        if (this.b != null) {
+            try {
+                File file = this.b.getDataFile(persistentbase.id);
+
+                if (file != null) {
+                    NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+                    persistentbase.b(nbttagcompound);
+                    NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+                    nbttagcompound1.set("data", nbttagcompound);
+                    FileOutputStream fileoutputstream = new FileOutputStream(file);
+
+                    NBTCompressedStreamTools.a(nbttagcompound1, (OutputStream) fileoutputstream);
+                    fileoutputstream.close();
+                }
+            } catch (Exception exception) {
+                exception.printStackTrace();
+            }
+
+        }
+    }
+
+    private void b() {
+        try {
+            this.d.clear();
+            if (this.b == null) {
+                return;
+            }
+
+            File file = this.b.getDataFile("idcounts");
+
+            if (file != null && file.exists()) {
+                DataInputStream datainputstream = new DataInputStream(new FileInputStream(file));
+                NBTTagCompound nbttagcompound = NBTCompressedStreamTools.a(datainputstream);
+
+                datainputstream.close();
+                Iterator iterator = nbttagcompound.c().iterator();
+
+                while (iterator.hasNext()) {
+                    String s = (String) iterator.next();
+                    NBTBase nbtbase = nbttagcompound.get(s);
+
+                    if (nbtbase instanceof NBTTagShort) {
+                        NBTTagShort nbttagshort = (NBTTagShort) nbtbase;
+                        short short0 = nbttagshort.e();
+
+                        this.d.put(s, Short.valueOf(short0));
+                    }
+                }
+            }
+        } catch (Exception exception) {
+            exception.printStackTrace();
+        }
+
+    }
+
+    public int a(String s) {
+        Short oshort = (Short) this.d.get(s);
+
+        if (oshort == null) {
+            oshort = Short.valueOf((short) 0);
+        } else {
+            oshort = Short.valueOf((short) (oshort.shortValue() + 1));
+        }
+
+        this.d.put(s, oshort);
+        if (this.b == null) {
+            return oshort.shortValue();
+        } else {
+            try {
+                File file = this.b.getDataFile("idcounts");
+
+                if (file != null) {
+                    NBTTagCompound nbttagcompound = new NBTTagCompound();
+                    Iterator iterator = this.d.keySet().iterator();
+
+                    while (iterator.hasNext()) {
+                        String s1 = (String) iterator.next();
+                        short short0 = ((Short) this.d.get(s1)).shortValue();
+
+                        nbttagcompound.setShort(s1, short0);
+                    }
+
+                    DataOutputStream dataoutputstream = new DataOutputStream(new FileOutputStream(file));
+
+                    NBTCompressedStreamTools.a(nbttagcompound, (DataOutput) dataoutputstream);
+                    dataoutputstream.close();
+                }
+            } catch (Exception exception) {
+                exception.printStackTrace();
+            }
+
+            return oshort.shortValue();
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/RegionFileCache.java b/src/main/java/net/minecraft/server/RegionFileCache.java
new file mode 100644
index 0000000..b07e7d5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RegionFileCache.java
@@ -0,0 +1,67 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Maps;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Map;
+
+public class RegionFileCache {
+
+    private static final Map<File, RegionFile> a = Maps.newHashMap();
+
+    public static synchronized RegionFile a(File file, int i, int j) {
+        File file1 = new File(file, "region");
+        File file2 = new File(file1, "r." + (i >> 5) + "." + (j >> 5) + ".mca");
+        RegionFile regionfile = (RegionFile) RegionFileCache.a.get(file2);
+
+        if (regionfile != null) {
+            return regionfile;
+        } else {
+            if (!file1.exists()) {
+                file1.mkdirs();
+            }
+
+            if (RegionFileCache.a.size() >= 256) {
+                a();
+            }
+
+            RegionFile regionfile1 = new RegionFile(file2);
+
+            RegionFileCache.a.put(file2, regionfile1);
+            return regionfile1;
+        }
+    }
+
+    public static synchronized void a() {
+        Iterator iterator = RegionFileCache.a.values().iterator();
+
+        while (iterator.hasNext()) {
+            RegionFile regionfile = (RegionFile) iterator.next();
+
+            try {
+                if (regionfile != null) {
+                    regionfile.c();
+                }
+            } catch (IOException ioexception) {
+                ioexception.printStackTrace();
+            }
+        }
+
+        RegionFileCache.a.clear();
+    }
+
+    public static DataInputStream c(File file, int i, int j) {
+        RegionFile regionfile = a(file, i, j);
+
+        return regionfile.a(i & 31, j & 31);
+    }
+
+    public static DataOutputStream d(File file, int i, int j) {
+        RegionFile regionfile = a(file, i, j);
+
+        return regionfile.b(i & 31, j & 31);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ServerConnection.java b/src/main/java/net/minecraft/server/ServerConnection.java
new file mode 100644
index 0000000..86b1f37
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ServerConnection.java
@@ -0,0 +1,175 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelException;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.epoll.Epoll;
+import io.netty.channel.epoll.EpollEventLoopGroup;
+import io.netty.channel.epoll.EpollServerSocketChannel;
+import io.netty.channel.local.LocalEventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.timeout.ReadTimeoutHandler;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.Callable;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class ServerConnection {
+
+    private static final Logger e = LogManager.getLogger();
+    public static final LazyInitVar<NioEventLoopGroup> a = new LazyInitVar() {
+        protected NioEventLoopGroup a() {
+            return new NioEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Server IO #%d").setDaemon(true).build());
+        }
+
+        protected Object init() {
+            return this.a();
+        }
+    };
+    public static final LazyInitVar<EpollEventLoopGroup> b = new LazyInitVar() {
+        protected EpollEventLoopGroup a() {
+            return new EpollEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Epoll Server IO #%d").setDaemon(true).build());
+        }
+
+        protected Object init() {
+            return this.a();
+        }
+    };
+    public static final LazyInitVar<LocalEventLoopGroup> c = new LazyInitVar() {
+        protected LocalEventLoopGroup a() {
+            return new LocalEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Local Server IO #%d").setDaemon(true).build());
+        }
+
+        protected Object init() {
+            return this.a();
+        }
+    };
+    private final MinecraftServer f;
+    public volatile boolean d;
+    private final List<ChannelFuture> g = Collections.synchronizedList(Lists.<ChannelFuture>newArrayList());
+    private final List<NetworkManager> h = Collections.synchronizedList(Lists.<NetworkManager>newArrayList());
+
+    public ServerConnection(MinecraftServer minecraftserver) {
+        this.f = minecraftserver;
+        this.d = true;
+    }
+
+    public void a(InetAddress inetaddress, int i) throws IOException {
+        List list = this.g;
+
+        synchronized (this.g) {
+            Class oclass;
+            LazyInitVar lazyinitvar;
+
+            if (Epoll.isAvailable() && this.f.ai()) {
+                oclass = EpollServerSocketChannel.class;
+                lazyinitvar = ServerConnection.b;
+                ServerConnection.e.info("Using epoll channel type");
+            } else {
+                oclass = NioServerSocketChannel.class;
+                lazyinitvar = ServerConnection.a;
+                ServerConnection.e.info("Using default channel type");
+            }
+
+            this.g.add(((ServerBootstrap) ((ServerBootstrap) (new ServerBootstrap()).channel(oclass)).childHandler(new ChannelInitializer() {
+                protected void initChannel(Channel channel) throws Exception {
+                    try {
+                        channel.config().setOption(ChannelOption.TCP_NODELAY, Boolean.valueOf(true));
+                    } catch (ChannelException channelexception) {
+                        ;
+                    }
+
+                    channel.pipeline().addLast("timeout", new ReadTimeoutHandler(30)).addLast("legacy_query", new LegacyPingHandler(ServerConnection.this)).addLast("splitter", new PacketSplitter()).addLast("decoder", new PacketDecoder(EnumProtocolDirection.SERVERBOUND)).addLast("prepender", new PacketPrepender()).addLast("encoder", new PacketEncoder(EnumProtocolDirection.CLIENTBOUND));
+                    NetworkManager networkmanager = new NetworkManager(EnumProtocolDirection.SERVERBOUND);
+
+                    ServerConnection.this.h.add(networkmanager);
+                    channel.pipeline().addLast("packet_handler", networkmanager);
+                    networkmanager.a((PacketListener) (new HandshakeListener(ServerConnection.this.f, networkmanager)));
+                }
+            }).group((EventLoopGroup) lazyinitvar.c()).localAddress(inetaddress, i)).bind().syncUninterruptibly());
+        }
+    }
+
+    public void b() {
+        this.d = false;
+        Iterator iterator = this.g.iterator();
+
+        while (iterator.hasNext()) {
+            ChannelFuture channelfuture = (ChannelFuture) iterator.next();
+
+            try {
+                channelfuture.channel().close().sync();
+            } catch (InterruptedException interruptedexception) {
+                ServerConnection.e.error("Interrupted whilst closing channel");
+            }
+        }
+
+    }
+
+    public void c() {
+        List list = this.h;
+
+        synchronized (this.h) {
+            Iterator iterator = this.h.iterator();
+
+            while (iterator.hasNext()) {
+                final NetworkManager networkmanager = (NetworkManager) iterator.next();
+
+                if (!networkmanager.h()) {
+                    if (!networkmanager.g()) {
+                        iterator.remove();
+                        networkmanager.l();
+                    } else {
+                        try {
+                            networkmanager.a();
+                        } catch (Exception exception) {
+                            if (networkmanager.c()) {
+                                CrashReport crashreport = CrashReport.a(exception, "Ticking memory connection");
+                                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Ticking connection");
+
+                                crashreportsystemdetails.a("Connection", new Callable() {
+                                    public String a() throws Exception {
+                                        return networkmanager.toString();
+                                    }
+
+                                    public Object call() throws Exception {
+                                        return this.a();
+                                    }
+                                });
+                                throw new ReportedException(crashreport);
+                            }
+
+                            ServerConnection.e.warn("Failed to handle packet for " + networkmanager.getSocketAddress(), exception);
+                            final ChatComponentText chatcomponenttext = new ChatComponentText("Internal server error");
+
+                            networkmanager.a(new PacketPlayOutKickDisconnect(chatcomponenttext), new GenericFutureListener() {
+                                public void operationComplete(Future future) throws Exception {
+                                    networkmanager.close(chatcomponenttext);
+                                }
+                            }, new GenericFutureListener[0]);
+                            networkmanager.k();
+                        }
+                    }
+                }
+            }
+
+        }
+    }
+
+    public MinecraftServer d() {
+        return this.f;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ServerStatisticManager.java b/src/main/java/net/minecraft/server/ServerStatisticManager.java
new file mode 100644
index 0000000..46845cd
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ServerStatisticManager.java
@@ -0,0 +1,212 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonParser;
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Constructor;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.Map.Entry;
+import org.apache.commons.io.FileUtils;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class ServerStatisticManager extends StatisticManager {
+
+    private static final Logger b = LogManager.getLogger();
+    private final MinecraftServer c;
+    private final File d;
+    private final Set<Statistic> e = Sets.newHashSet();
+    private int f = -300;
+    private boolean g = false;
+
+    public ServerStatisticManager(MinecraftServer minecraftserver, File file) {
+        this.c = minecraftserver;
+        this.d = file;
+    }
+
+    public void a() {
+        if (this.d.isFile()) {
+            try {
+                this.a.clear();
+                this.a.putAll(this.a(FileUtils.readFileToString(this.d)));
+            } catch (IOException ioexception) {
+                ServerStatisticManager.b.error("Couldn\'t read statistics file " + this.d, ioexception);
+            } catch (JsonParseException jsonparseexception) {
+                ServerStatisticManager.b.error("Couldn\'t parse statistics file " + this.d, jsonparseexception);
+            }
+        }
+
+    }
+
+    public void b() {
+        try {
+            FileUtils.writeStringToFile(this.d, a(this.a));
+        } catch (IOException ioexception) {
+            ServerStatisticManager.b.error("Couldn\'t save stats", ioexception);
+        }
+
+    }
+
+    public void setStatistic(EntityHuman entityhuman, Statistic statistic, int i) {
+        int j = statistic.d() ? this.getStatisticValue(statistic) : 0;
+
+        super.setStatistic(entityhuman, statistic, i);
+        this.e.add(statistic);
+        if (statistic.d() && j == 0 && i > 0) {
+            this.g = true;
+            if (this.c.aB()) {
+                this.c.getPlayerList().sendMessage(new ChatMessage("chat.type.achievement", new Object[] { entityhuman.getScoreboardDisplayName(), statistic.j()}));
+            }
+        }
+
+        if (statistic.d() && j > 0 && i == 0) {
+            this.g = true;
+            if (this.c.aB()) {
+                this.c.getPlayerList().sendMessage(new ChatMessage("chat.type.achievement.taken", new Object[] { entityhuman.getScoreboardDisplayName(), statistic.j()}));
+            }
+        }
+
+    }
+
+    public Set<Statistic> c() {
+        HashSet hashset = Sets.newHashSet(this.e);
+
+        this.e.clear();
+        this.g = false;
+        return hashset;
+    }
+
+    public Map<Statistic, StatisticWrapper> a(String s) {
+        JsonElement jsonelement = (new JsonParser()).parse(s);
+
+        if (!jsonelement.isJsonObject()) {
+            return Maps.newHashMap();
+        } else {
+            JsonObject jsonobject = jsonelement.getAsJsonObject();
+            HashMap hashmap = Maps.newHashMap();
+            Iterator iterator = jsonobject.entrySet().iterator();
+
+            while (iterator.hasNext()) {
+                Entry entry = (Entry) iterator.next();
+                Statistic statistic = StatisticList.getStatistic((String) entry.getKey());
+
+                if (statistic != null) {
+                    StatisticWrapper statisticwrapper = new StatisticWrapper();
+
+                    if (((JsonElement) entry.getValue()).isJsonPrimitive() && ((JsonElement) entry.getValue()).getAsJsonPrimitive().isNumber()) {
+                        statisticwrapper.a(((JsonElement) entry.getValue()).getAsInt());
+                    } else if (((JsonElement) entry.getValue()).isJsonObject()) {
+                        JsonObject jsonobject1 = ((JsonElement) entry.getValue()).getAsJsonObject();
+
+                        if (jsonobject1.has("value") && jsonobject1.get("value").isJsonPrimitive() && jsonobject1.get("value").getAsJsonPrimitive().isNumber()) {
+                            statisticwrapper.a(jsonobject1.getAsJsonPrimitive("value").getAsInt());
+                        }
+
+                        if (jsonobject1.has("progress") && statistic.l() != null) {
+                            try {
+                                Constructor constructor = statistic.l().getConstructor(new Class[0]);
+                                IJsonStatistic ijsonstatistic = (IJsonStatistic) constructor.newInstance(new Object[0]);
+
+                                ijsonstatistic.a(jsonobject1.get("progress"));
+                                statisticwrapper.a(ijsonstatistic);
+                            } catch (Throwable throwable) {
+                                ServerStatisticManager.b.warn("Invalid statistic progress in " + this.d, throwable);
+                            }
+                        }
+                    }
+
+                    hashmap.put(statistic, statisticwrapper);
+                } else {
+                    ServerStatisticManager.b.warn("Invalid statistic in " + this.d + ": Don\'t know what " + (String) entry.getKey() + " is");
+                }
+            }
+
+            return hashmap;
+        }
+    }
+
+    public static String a(Map<Statistic, StatisticWrapper> map) {
+        JsonObject jsonobject = new JsonObject();
+        Iterator iterator = map.entrySet().iterator();
+
+        while (iterator.hasNext()) {
+            Entry entry = (Entry) iterator.next();
+
+            if (((StatisticWrapper) entry.getValue()).b() != null) {
+                JsonObject jsonobject1 = new JsonObject();
+
+                jsonobject1.addProperty("value", Integer.valueOf(((StatisticWrapper) entry.getValue()).a()));
+
+                try {
+                    jsonobject1.add("progress", ((StatisticWrapper) entry.getValue()).b().a());
+                } catch (Throwable throwable) {
+                    ServerStatisticManager.b.warn("Couldn\'t save statistic " + ((Statistic) entry.getKey()).e() + ": error serializing progress", throwable);
+                }
+
+                jsonobject.add(((Statistic) entry.getKey()).name, jsonobject1);
+            } else {
+                jsonobject.addProperty(((Statistic) entry.getKey()).name, Integer.valueOf(((StatisticWrapper) entry.getValue()).a()));
+            }
+        }
+
+        return jsonobject.toString();
+    }
+
+    public void d() {
+        Iterator iterator = this.a.keySet().iterator();
+
+        while (iterator.hasNext()) {
+            Statistic statistic = (Statistic) iterator.next();
+
+            this.e.add(statistic);
+        }
+
+    }
+
+    public void a(EntityPlayer entityplayer) {
+        int i = this.c.at();
+        HashMap hashmap = Maps.newHashMap();
+
+        if (this.g || i - this.f > 300) {
+            this.f = i;
+            Iterator iterator = this.c().iterator();
+
+            while (iterator.hasNext()) {
+                Statistic statistic = (Statistic) iterator.next();
+
+                hashmap.put(statistic, Integer.valueOf(this.getStatisticValue(statistic)));
+            }
+        }
+
+        entityplayer.playerConnection.sendPacket(new PacketPlayOutStatistic(hashmap));
+    }
+
+    public void updateStatistics(EntityPlayer entityplayer) {
+        HashMap hashmap = Maps.newHashMap();
+        Iterator iterator = AchievementList.e.iterator();
+
+        while (iterator.hasNext()) {
+            Achievement achievement = (Achievement) iterator.next();
+
+            if (this.hasAchievement(achievement)) {
+                hashmap.put(achievement, Integer.valueOf(this.getStatisticValue(achievement)));
+                this.e.remove(achievement);
+            }
+        }
+
+        entityplayer.playerConnection.sendPacket(new PacketPlayOutStatistic(hashmap));
+    }
+
+    public boolean e() {
+        return this.g;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/StructureGenerator.java b/src/main/java/net/minecraft/server/StructureGenerator.java
new file mode 100644
index 0000000..0bced98
--- /dev/null
+++ b/src/main/java/net/minecraft/server/StructureGenerator.java
@@ -0,0 +1,237 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Maps;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.Callable;
+
+public abstract class StructureGenerator extends WorldGenBase {
+
+    private PersistentStructure d;
+    protected Map<Long, StructureStart> e = Maps.newHashMap();
+
+    public StructureGenerator() {}
+
+    public abstract String a();
+
+    protected final void a(World world, final int i, final int j, int k, int l, ChunkSnapshot chunksnapshot) {
+        this.a(world);
+        if (!this.e.containsKey(Long.valueOf(ChunkCoordIntPair.a(i, j)))) {
+            this.b.nextInt();
+
+            try {
+                if (this.a(i, j)) {
+                    StructureStart structurestart = this.b(i, j);
+
+                    this.e.put(Long.valueOf(ChunkCoordIntPair.a(i, j)), structurestart);
+                    this.a(i, j, structurestart);
+                }
+
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Exception preparing structure feature");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Feature being prepared");
+
+                crashreportsystemdetails.a("Is feature chunk", new Callable() {
+                    public String a() throws Exception {
+                        return StructureGenerator.this.a(i, j) ? "True" : "False";
+                    }
+
+                    public Object call() throws Exception {
+                        return this.a();
+                    }
+                });
+                crashreportsystemdetails.a("Chunk location", (Object) String.format("%d,%d", new Object[] { Integer.valueOf(i), Integer.valueOf(j)}));
+                crashreportsystemdetails.a("Chunk pos hash", new Callable() {
+                    public String a() throws Exception {
+                        return String.valueOf(ChunkCoordIntPair.a(i, j));
+                    }
+
+                    public Object call() throws Exception {
+                        return this.a();
+                    }
+                });
+                crashreportsystemdetails.a("Structure type", new Callable() {
+                    public String a() throws Exception {
+                        return StructureGenerator.this.getClass().getCanonicalName();
+                    }
+
+                    public Object call() throws Exception {
+                        return this.a();
+                    }
+                });
+                throw new ReportedException(crashreport);
+            }
+        }
+    }
+
+    public boolean a(World world, Random random, ChunkCoordIntPair chunkcoordintpair) {
+        this.a(world);
+        int i = (chunkcoordintpair.x << 4) + 8;
+        int j = (chunkcoordintpair.z << 4) + 8;
+        boolean flag = false;
+        Iterator iterator = this.e.values().iterator();
+
+        while (iterator.hasNext()) {
+            StructureStart structurestart = (StructureStart) iterator.next();
+
+            if (structurestart.d() && structurestart.a(chunkcoordintpair) && structurestart.a().a(i, j, i + 15, j + 15)) {
+                structurestart.a(world, random, new StructureBoundingBox(i, j, i + 15, j + 15));
+                structurestart.b(chunkcoordintpair);
+                flag = true;
+                this.a(structurestart.e(), structurestart.f(), structurestart);
+            }
+        }
+
+        return flag;
+    }
+
+    public boolean b(BlockPosition blockposition) {
+        this.a(this.c);
+        return this.c(blockposition) != null;
+    }
+
+    protected StructureStart c(BlockPosition blockposition) {
+        Iterator iterator = this.e.values().iterator();
+
+        while (iterator.hasNext()) {
+            StructureStart structurestart = (StructureStart) iterator.next();
+
+            if (structurestart.d() && structurestart.a().b((BaseBlockPosition) blockposition)) {
+                Iterator iterator1 = structurestart.b().iterator();
+
+                while (iterator1.hasNext()) {
+                    StructurePiece structurepiece = (StructurePiece) iterator1.next();
+
+                    if (structurepiece.c().b((BaseBlockPosition) blockposition)) {
+                        return structurestart;
+                    }
+                }
+            }
+        }
+
+        return null;
+    }
+
+    public boolean a(World world, BlockPosition blockposition) {
+        this.a(world);
+        Iterator iterator = this.e.values().iterator();
+
+        StructureStart structurestart;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            structurestart = (StructureStart) iterator.next();
+        } while (!structurestart.d() || !structurestart.a().b((BaseBlockPosition) blockposition));
+
+        return true;
+    }
+
+    public BlockPosition getNearestGeneratedFeature(World world, BlockPosition blockposition) {
+        this.c = world;
+        this.a(world);
+        this.b.setSeed(world.getSeed());
+        long i = this.b.nextLong();
+        long j = this.b.nextLong();
+        long k = (long) (blockposition.getX() >> 4) * i;
+        long l = (long) (blockposition.getZ() >> 4) * j;
+
+        this.b.setSeed(k ^ l ^ world.getSeed());
+        this.a(world, blockposition.getX() >> 4, blockposition.getZ() >> 4, 0, 0, (ChunkSnapshot) null);
+        double d0 = Double.MAX_VALUE;
+        BlockPosition blockposition1 = null;
+        Iterator iterator = this.e.values().iterator();
+
+        BlockPosition blockposition2;
+        double d1;
+
+        while (iterator.hasNext()) {
+            StructureStart structurestart = (StructureStart) iterator.next();
+
+            if (structurestart.d()) {
+                StructurePiece structurepiece = (StructurePiece) structurestart.b().get(0);
+
+                blockposition2 = structurepiece.a();
+                d1 = blockposition2.i(blockposition);
+                if (d1 < d0) {
+                    d0 = d1;
+                    blockposition1 = blockposition2;
+                }
+            }
+        }
+
+        if (blockposition1 != null) {
+            return blockposition1;
+        } else {
+            List list = this.z_();
+
+            if (list != null) {
+                BlockPosition blockposition3 = null;
+                Iterator iterator1 = list.iterator();
+
+                while (iterator1.hasNext()) {
+                    blockposition2 = (BlockPosition) iterator1.next();
+                    d1 = blockposition2.i(blockposition);
+                    if (d1 < d0) {
+                        d0 = d1;
+                        blockposition3 = blockposition2;
+                    }
+                }
+
+                return blockposition3;
+            } else {
+                return null;
+            }
+        }
+    }
+
+    protected List<BlockPosition> z_() {
+        return null;
+    }
+
+    private void a(World world) {
+        if (this.d == null) {
+            this.d = (PersistentStructure) world.a(PersistentStructure.class, this.a());
+            if (this.d == null) {
+                this.d = new PersistentStructure(this.a());
+                world.a(this.a(), (PersistentBase) this.d);
+            } else {
+                NBTTagCompound nbttagcompound = this.d.a();
+                Iterator iterator = nbttagcompound.c().iterator();
+
+                while (iterator.hasNext()) {
+                    String s = (String) iterator.next();
+                    NBTBase nbtbase = nbttagcompound.get(s);
+
+                    if (nbtbase.getTypeId() == 10) {
+                        NBTTagCompound nbttagcompound1 = (NBTTagCompound) nbtbase;
+
+                        if (nbttagcompound1.hasKey("ChunkX") && nbttagcompound1.hasKey("ChunkZ")) {
+                            int i = nbttagcompound1.getInt("ChunkX");
+                            int j = nbttagcompound1.getInt("ChunkZ");
+                            StructureStart structurestart = WorldGenFactory.a(nbttagcompound1, world);
+
+                            if (structurestart != null) {
+                                this.e.put(Long.valueOf(ChunkCoordIntPair.a(i, j)), structurestart);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    private void a(int i, int j, StructureStart structurestart) {
+        this.d.a(structurestart.a(i, j), i, j);
+        this.d.c();
+    }
+
+    protected abstract boolean a(int i, int j);
+
+    protected abstract StructureStart b(int i, int j);
+}
diff --git a/src/main/java/net/minecraft/server/WorldGenForestTree.java b/src/main/java/net/minecraft/server/WorldGenForestTree.java
new file mode 100644
index 0000000..ffbc47d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldGenForestTree.java
@@ -0,0 +1,178 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class WorldGenForestTree extends WorldGenTreeAbstract {
+
+    private static final IBlockData a = Blocks.LOG2.getBlockData().set(BlockLog2.VARIANT, BlockWood.EnumLogVariant.DARK_OAK);
+    private static final IBlockData b = Blocks.LEAVES2.getBlockData().set(BlockLeaves2.VARIANT, BlockWood.EnumLogVariant.DARK_OAK).set(BlockLeaves.CHECK_DECAY, Boolean.valueOf(false));
+
+    public WorldGenForestTree(boolean flag) {
+        super(flag);
+    }
+
+    public boolean generate(World world, Random random, BlockPosition blockposition) {
+        int i = random.nextInt(3) + random.nextInt(2) + 6;
+        int j = blockposition.getX();
+        int k = blockposition.getY();
+        int l = blockposition.getZ();
+
+        if (k >= 1 && k + i + 1 < 256) {
+            BlockPosition blockposition1 = blockposition.down();
+            Block block = world.getType(blockposition1).getBlock();
+
+            if (block != Blocks.GRASS && block != Blocks.DIRT) {
+                return false;
+            } else if (!this.a(world, blockposition, i)) {
+                return false;
+            } else {
+                this.a(world, blockposition1);
+                this.a(world, blockposition1.east());
+                this.a(world, blockposition1.south());
+                this.a(world, blockposition1.south().east());
+                EnumDirection enumdirection = EnumDirection.EnumDirectionLimit.HORIZONTAL.a(random);
+                int i1 = i - random.nextInt(4);
+                int j1 = 2 - random.nextInt(3);
+                int k1 = j;
+                int l1 = l;
+                int i2 = k + i - 1;
+
+                int j2;
+                int k2;
+
+                for (j2 = 0; j2 < i; ++j2) {
+                    if (j2 >= i1 && j1 > 0) {
+                        k1 += enumdirection.getAdjacentX();
+                        l1 += enumdirection.getAdjacentZ();
+                        --j1;
+                    }
+
+                    k2 = k + j2;
+                    BlockPosition blockposition2 = new BlockPosition(k1, k2, l1);
+                    Material material = world.getType(blockposition2).getBlock().getMaterial();
+
+                    if (material == Material.AIR || material == Material.LEAVES) {
+                        this.b(world, blockposition2);
+                        this.b(world, blockposition2.east());
+                        this.b(world, blockposition2.south());
+                        this.b(world, blockposition2.east().south());
+                    }
+                }
+
+                for (j2 = -2; j2 <= 0; ++j2) {
+                    for (k2 = -2; k2 <= 0; ++k2) {
+                        byte b0 = -1;
+
+                        this.a(world, k1 + j2, i2 + b0, l1 + k2);
+                        this.a(world, 1 + k1 - j2, i2 + b0, l1 + k2);
+                        this.a(world, k1 + j2, i2 + b0, 1 + l1 - k2);
+                        this.a(world, 1 + k1 - j2, i2 + b0, 1 + l1 - k2);
+                        if ((j2 > -2 || k2 > -1) && (j2 != -1 || k2 != -2)) {
+                            byte b1 = 1;
+
+                            this.a(world, k1 + j2, i2 + b1, l1 + k2);
+                            this.a(world, 1 + k1 - j2, i2 + b1, l1 + k2);
+                            this.a(world, k1 + j2, i2 + b1, 1 + l1 - k2);
+                            this.a(world, 1 + k1 - j2, i2 + b1, 1 + l1 - k2);
+                        }
+                    }
+                }
+
+                if (random.nextBoolean()) {
+                    this.a(world, k1, i2 + 2, l1);
+                    this.a(world, k1 + 1, i2 + 2, l1);
+                    this.a(world, k1 + 1, i2 + 2, l1 + 1);
+                    this.a(world, k1, i2 + 2, l1 + 1);
+                }
+
+                for (j2 = -3; j2 <= 4; ++j2) {
+                    for (k2 = -3; k2 <= 4; ++k2) {
+                        if ((j2 != -3 || k2 != -3) && (j2 != -3 || k2 != 4) && (j2 != 4 || k2 != -3) && (j2 != 4 || k2 != 4) && (Math.abs(j2) < 3 || Math.abs(k2) < 3)) {
+                            this.a(world, k1 + j2, i2, l1 + k2);
+                        }
+                    }
+                }
+
+                for (j2 = -1; j2 <= 2; ++j2) {
+                    for (k2 = -1; k2 <= 2; ++k2) {
+                        if ((j2 < 0 || j2 > 1 || k2 < 0 || k2 > 1) && random.nextInt(3) <= 0) {
+                            int l2 = random.nextInt(3) + 2;
+
+                            int i3;
+
+                            for (i3 = 0; i3 < l2; ++i3) {
+                                this.b(world, new BlockPosition(j + j2, i2 - i3 - 1, l + k2));
+                            }
+
+                            int j3;
+
+                            for (i3 = -1; i3 <= 1; ++i3) {
+                                for (j3 = -1; j3 <= 1; ++j3) {
+                                    this.a(world, k1 + j2 + i3, i2, l1 + k2 + j3);
+                                }
+                            }
+
+                            for (i3 = -2; i3 <= 2; ++i3) {
+                                for (j3 = -2; j3 <= 2; ++j3) {
+                                    if (Math.abs(i3) != 2 || Math.abs(j3) != 2) {
+                                        this.a(world, k1 + j2 + i3, i2 - 1, l1 + k2 + j3);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+
+                return true;
+            }
+        } else {
+            return false;
+        }
+    }
+
+    private boolean a(World world, BlockPosition blockposition, int i) {
+        int j = blockposition.getX();
+        int k = blockposition.getY();
+        int l = blockposition.getZ();
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+
+        for (int i1 = 0; i1 <= i + 1; ++i1) {
+            byte b0 = 1;
+
+            if (i1 == 0) {
+                b0 = 0;
+            }
+
+            if (i1 >= i - 1) {
+                b0 = 2;
+            }
+
+            for (int j1 = -b0; j1 <= b0; ++j1) {
+                for (int k1 = -b0; k1 <= b0; ++k1) {
+                    if (!this.a(world.getType(blockposition_mutableblockposition.c(j + j1, k + i1, l + k1)).getBlock())) {
+                        return false;
+                    }
+                }
+            }
+        }
+
+        return true;
+    }
+
+    private void b(World world, BlockPosition blockposition) {
+        if (this.a(world.getType(blockposition).getBlock())) {
+            this.a(world, blockposition, WorldGenForestTree.a);
+        }
+
+    }
+
+    private void a(World world, int i, int j, int k) {
+        BlockPosition blockposition = new BlockPosition(i, j, k);
+        Block block = world.getType(blockposition).getBlock();
+
+        if (block.getMaterial() == Material.AIR) {
+            this.a(world, blockposition, WorldGenForestTree.b);
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldGenLargeFeature.java b/src/main/java/net/minecraft/server/WorldGenLargeFeature.java
new file mode 100644
index 0000000..b2f87cc
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldGenLargeFeature.java
@@ -0,0 +1,131 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Map.Entry;
+
+public class WorldGenLargeFeature extends StructureGenerator {
+
+    private static final List<BiomeBase> d = Arrays.asList(new BiomeBase[] { BiomeBase.DESERT, BiomeBase.DESERT_HILLS, BiomeBase.JUNGLE, BiomeBase.JUNGLE_HILLS, BiomeBase.SWAMPLAND});
+    private List<BiomeBase.BiomeMeta> f;
+    private int g;
+    private int h;
+
+    public WorldGenLargeFeature() {
+        this.f = Lists.newArrayList();
+        this.g = 32;
+        this.h = 8;
+        this.f.add(new BiomeBase.BiomeMeta(EntityWitch.class, 1, 1, 1));
+    }
+
+    public WorldGenLargeFeature(Map<String, String> map) {
+        this();
+        Iterator iterator = map.entrySet().iterator();
+
+        while (iterator.hasNext()) {
+            Entry entry = (Entry) iterator.next();
+
+            if (((String) entry.getKey()).equals("distance")) {
+                this.g = MathHelper.a((String) entry.getValue(), this.g, this.h + 1);
+            }
+        }
+
+    }
+
+    public String a() {
+        return "Temple";
+    }
+
+    protected boolean a(int i, int j) {
+        int k = i;
+        int l = j;
+
+        if (i < 0) {
+            i -= this.g - 1;
+        }
+
+        if (j < 0) {
+            j -= this.g - 1;
+        }
+
+        int i1 = i / this.g;
+        int j1 = j / this.g;
+        Random random = this.c.a(i1, j1, 14357617);
+
+        i1 *= this.g;
+        j1 *= this.g;
+        i1 += random.nextInt(this.g - this.h);
+        j1 += random.nextInt(this.g - this.h);
+        if (k == i1 && l == j1) {
+            BiomeBase biomebase = this.c.getWorldChunkManager().getBiome(new BlockPosition(k * 16 + 8, 0, l * 16 + 8));
+
+            if (biomebase == null) {
+                return false;
+            }
+
+            Iterator iterator = WorldGenLargeFeature.d.iterator();
+
+            while (iterator.hasNext()) {
+                BiomeBase biomebase1 = (BiomeBase) iterator.next();
+
+                if (biomebase == biomebase1) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    protected StructureStart b(int i, int j) {
+        return new WorldGenLargeFeature.WorldGenLargeFeatureStart(this.c, this.b, i, j);
+    }
+
+    public boolean a(BlockPosition blockposition) {
+        StructureStart structurestart = this.c(blockposition);
+
+        if (structurestart != null && structurestart instanceof WorldGenLargeFeature.WorldGenLargeFeatureStart && !structurestart.a.isEmpty()) {
+            StructurePiece structurepiece = (StructurePiece) structurestart.a.getFirst();
+
+            return structurepiece instanceof WorldGenRegistration.WorldGenWitchHut;
+        } else {
+            return false;
+        }
+    }
+
+    public List<BiomeBase.BiomeMeta> b() {
+        return this.f;
+    }
+
+    public static class WorldGenLargeFeatureStart extends StructureStart {
+
+        public WorldGenLargeFeatureStart() {}
+
+        public WorldGenLargeFeatureStart(World world, Random random, int i, int j) {
+            super(i, j);
+            BiomeBase biomebase = world.getBiome(new BlockPosition(i * 16 + 8, 0, j * 16 + 8));
+
+            if (biomebase != BiomeBase.JUNGLE && biomebase != BiomeBase.JUNGLE_HILLS) {
+                if (biomebase == BiomeBase.SWAMPLAND) {
+                    WorldGenRegistration.WorldGenWitchHut worldgenregistration_worldgenwitchhut = new WorldGenRegistration.WorldGenWitchHut(random, i * 16, j * 16);
+
+                    this.a.add(worldgenregistration_worldgenwitchhut);
+                } else if (biomebase == BiomeBase.DESERT || biomebase == BiomeBase.DESERT_HILLS) {
+                    WorldGenRegistration.WorldGenPyramidPiece worldgenregistration_worldgenpyramidpiece = new WorldGenRegistration.WorldGenPyramidPiece(random, i * 16, j * 16);
+
+                    this.a.add(worldgenregistration_worldgenpyramidpiece);
+                }
+            } else {
+                WorldGenRegistration.WorldGenJungleTemple worldgenregistration_worldgenjungletemple = new WorldGenRegistration.WorldGenJungleTemple(random, i * 16, j * 16);
+
+                this.a.add(worldgenregistration_worldgenjungletemple);
+            }
+
+            this.c();
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldGenPackedIce2.java b/src/main/java/net/minecraft/server/WorldGenPackedIce2.java
new file mode 100644
index 0000000..dcd085a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldGenPackedIce2.java
@@ -0,0 +1,100 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class WorldGenPackedIce2 extends WorldGenerator {
+
+    public WorldGenPackedIce2() {}
+
+    public boolean generate(World world, Random random, BlockPosition blockposition) {
+        while (world.isEmpty(blockposition) && blockposition.getY() > 2) {
+            blockposition = blockposition.down();
+        }
+
+        if (world.getType(blockposition).getBlock() != Blocks.SNOW) {
+            return false;
+        } else {
+            blockposition = blockposition.up(random.nextInt(4));
+            int i = random.nextInt(4) + 7;
+            int j = i / 4 + random.nextInt(2);
+
+            if (j > 1 && random.nextInt(60) == 0) {
+                blockposition = blockposition.up(10 + random.nextInt(30));
+            }
+
+            int k;
+            int l;
+
+            for (k = 0; k < i; ++k) {
+                float f = (1.0F - (float) k / (float) i) * (float) j;
+
+                l = MathHelper.f(f);
+
+                for (int i1 = -l; i1 <= l; ++i1) {
+                    float f1 = (float) MathHelper.a(i1) - 0.25F;
+
+                    for (int j1 = -l; j1 <= l; ++j1) {
+                        float f2 = (float) MathHelper.a(j1) - 0.25F;
+
+                        if ((i1 == 0 && j1 == 0 || f1 * f1 + f2 * f2 <= f * f) && (i1 != -l && i1 != l && j1 != -l && j1 != l || random.nextFloat() <= 0.75F)) {
+                            Block block = world.getType(blockposition.a(i1, k, j1)).getBlock();
+
+                            if (block.getMaterial() == Material.AIR || block == Blocks.DIRT || block == Blocks.SNOW || block == Blocks.ICE) {
+                                this.a(world, blockposition.a(i1, k, j1), Blocks.PACKED_ICE.getBlockData());
+                            }
+
+                            if (k != 0 && l > 1) {
+                                block = world.getType(blockposition.a(i1, -k, j1)).getBlock();
+                                if (block.getMaterial() == Material.AIR || block == Blocks.DIRT || block == Blocks.SNOW || block == Blocks.ICE) {
+                                    this.a(world, blockposition.a(i1, -k, j1), Blocks.PACKED_ICE.getBlockData());
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            k = j - 1;
+            if (k < 0) {
+                k = 0;
+            } else if (k > 1) {
+                k = 1;
+            }
+
+            for (int k1 = -k; k1 <= k; ++k1) {
+                l = -k;
+
+                while (l <= k) {
+                    BlockPosition blockposition1 = blockposition.a(k1, -1, l);
+                    int l1 = 50;
+
+                    if (Math.abs(k1) == 1 && Math.abs(l) == 1) {
+                        l1 = random.nextInt(5);
+                    }
+
+                    while (true) {
+                        if (blockposition1.getY() > 50) {
+                            Block block1 = world.getType(blockposition1).getBlock();
+
+                            if (block1.getMaterial() == Material.AIR || block1 == Blocks.DIRT || block1 == Blocks.SNOW || block1 == Blocks.ICE || block1 == Blocks.PACKED_ICE) {
+                                this.a(world, blockposition1, Blocks.PACKED_ICE.getBlockData());
+                                blockposition1 = blockposition1.down();
+                                --l1;
+                                if (l1 <= 0) {
+                                    blockposition1 = blockposition1.down(random.nextInt(5) + 1);
+                                    l1 = random.nextInt(5);
+                                }
+                                continue;
+                            }
+                        }
+
+                        ++l;
+                        break;
+                    }
+                }
+            }
+
+            return true;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldGenVillage.java b/src/main/java/net/minecraft/server/WorldGenVillage.java
new file mode 100644
index 0000000..411f2dc
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldGenVillage.java
@@ -0,0 +1,138 @@
+package net.minecraft.server;
+
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Map.Entry;
+
+public class WorldGenVillage extends StructureGenerator {
+
+    public static final List<BiomeBase> d = Arrays.asList(new BiomeBase[] { BiomeBase.PLAINS, BiomeBase.DESERT, BiomeBase.SAVANNA});
+    private int f;
+    private int g;
+    private int h;
+
+    public WorldGenVillage() {
+        this.g = 32;
+        this.h = 8;
+    }
+
+    public WorldGenVillage(Map<String, String> map) {
+        this();
+        Iterator iterator = map.entrySet().iterator();
+
+        while (iterator.hasNext()) {
+            Entry entry = (Entry) iterator.next();
+
+            if (((String) entry.getKey()).equals("size")) {
+                this.f = MathHelper.a((String) entry.getValue(), this.f, 0);
+            } else if (((String) entry.getKey()).equals("distance")) {
+                this.g = MathHelper.a((String) entry.getValue(), this.g, this.h + 1);
+            }
+        }
+
+    }
+
+    public String a() {
+        return "Village";
+    }
+
+    protected boolean a(int i, int j) {
+        int k = i;
+        int l = j;
+
+        if (i < 0) {
+            i -= this.g - 1;
+        }
+
+        if (j < 0) {
+            j -= this.g - 1;
+        }
+
+        int i1 = i / this.g;
+        int j1 = j / this.g;
+        Random random = this.c.a(i1, j1, 10387312);
+
+        i1 *= this.g;
+        j1 *= this.g;
+        i1 += random.nextInt(this.g - this.h);
+        j1 += random.nextInt(this.g - this.h);
+        if (k == i1 && l == j1) {
+            boolean flag = this.c.getWorldChunkManager().a(k * 16 + 8, l * 16 + 8, 0, WorldGenVillage.d);
+
+            if (flag) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    protected StructureStart b(int i, int j) {
+        return new WorldGenVillage.WorldGenVillageStart(this.c, this.b, i, j, this.f);
+    }
+
+    public static class WorldGenVillageStart extends StructureStart {
+
+        private boolean c;
+
+        public WorldGenVillageStart() {}
+
+        public WorldGenVillageStart(World world, Random random, int i, int j, int k) {
+            super(i, j);
+            List list = WorldGenVillagePieces.a(random, k);
+            WorldGenVillagePieces.WorldGenVillageStartPiece worldgenvillagepieces_worldgenvillagestartpiece = new WorldGenVillagePieces.WorldGenVillageStartPiece(world.getWorldChunkManager(), 0, random, (i << 4) + 2, (j << 4) + 2, list, k);
+
+            this.a.add(worldgenvillagepieces_worldgenvillagestartpiece);
+            worldgenvillagepieces_worldgenvillagestartpiece.a((StructurePiece) worldgenvillagepieces_worldgenvillagestartpiece, (List) this.a, random);
+            List list1 = worldgenvillagepieces_worldgenvillagestartpiece.g;
+            List list2 = worldgenvillagepieces_worldgenvillagestartpiece.f;
+
+            int l;
+
+            while (!list1.isEmpty() || !list2.isEmpty()) {
+                StructurePiece structurepiece;
+
+                if (list1.isEmpty()) {
+                    l = random.nextInt(list2.size());
+                    structurepiece = (StructurePiece) list2.remove(l);
+                    structurepiece.a((StructurePiece) worldgenvillagepieces_worldgenvillagestartpiece, (List) this.a, random);
+                } else {
+                    l = random.nextInt(list1.size());
+                    structurepiece = (StructurePiece) list1.remove(l);
+                    structurepiece.a((StructurePiece) worldgenvillagepieces_worldgenvillagestartpiece, (List) this.a, random);
+                }
+            }
+
+            this.c();
+            l = 0;
+            Iterator iterator = this.a.iterator();
+
+            while (iterator.hasNext()) {
+                StructurePiece structurepiece1 = (StructurePiece) iterator.next();
+
+                if (!(structurepiece1 instanceof WorldGenVillagePieces.WorldGenVillageRoadPiece)) {
+                    ++l;
+                }
+            }
+
+            this.c = l > 2;
+        }
+
+        public boolean d() {
+            return this.c;
+        }
+
+        public void a(NBTTagCompound nbttagcompound) {
+            super.a(nbttagcompound);
+            nbttagcompound.setBoolean("Valid", this.c);
+        }
+
+        public void b(NBTTagCompound nbttagcompound) {
+            super.b(nbttagcompound);
+            this.c = nbttagcompound.getBoolean("Valid");
+        }
+    }
+}
diff --git a/src/main/java/org/spigotmc/SneakyThrow.java b/src/main/java/org/spigotmc/SneakyThrow.java
new file mode 100644
index 0000000..31fc0a9
--- /dev/null
+++ b/src/main/java/org/spigotmc/SneakyThrow.java
@@ -0,0 +1,15 @@
+package org.spigotmc;
+
+public class SneakyThrow
+{
+
+    public static void sneaky(Throwable t)
+    {
+        throw SneakyThrow.<RuntimeException>superSneaky( t );
+    }
+
+    private static <T extends Throwable> T superSneaky(Throwable t) throws T
+    {
+        throw (T) t;
+    }
+}
-- 
1.9.1

